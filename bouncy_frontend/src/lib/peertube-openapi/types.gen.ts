// This file is auto-generated by @hey-api/openapi-ts

export type Id = number;

export type UuiDv4 = string;

/**
 * translation of a uuid v4 with a bigger alphabet to have a shorter uuid
 */
export type ShortUuid = string;

/**
 * immutable name of the user, used to find or mention its actor
 */
export type Username = string;

/**
 * immutable name of the channel, used to interact with its actor
 */
export type UsernameChannel = string;

export type Password = string;

/**
 * category id of the video (see [/videos/categories](#operation/getCategories))
 */
export type VideoCategorySet = number;

export type VideoConstantNumberCategory = {
    id?: VideoCategorySet;
    label?: string;
};

/**
 * licence id of the video (see [/videos/licences](#operation/getLicences))
 */
export type VideoLicenceSet = number;

export type VideoConstantNumberLicence = {
    id?: VideoLicenceSet;
    label?: string;
};

/**
 * language id of the video (see [/videos/languages](#operation/getLanguages))
 */
export type VideoLanguageSet = string;

export type VideoConstantStringLanguage = {
    id?: VideoLanguageSet;
    label?: string;
};

/**
 * Video playlist privacy policy (see [/video-playlists/privacies](#operation/getPlaylistPrivacyPolicies))
 */
export type VideoPlaylistPrivacySet = 1 | 2 | 3;

export type VideoPlaylistPrivacyConstant = {
    id?: VideoPlaylistPrivacySet;
    label?: string;
};

/**
 * The video playlist type (Regular = `1`, Watch Later = `2`)
 */
export type VideoPlaylistTypeSet = 1 | 2;

export type VideoPlaylistTypeConstant = {
    id?: VideoPlaylistTypeSet;
    label?: string;
};

/**
 * privacy id of the video (see [/videos/privacies](#operation/getVideoPrivacyPolicies))
 */
export type VideoPrivacySet = 1 | 2 | 3 | 4 | 5;

export type VideoPrivacyConstant = {
    id?: VideoPrivacySet;
    label?: string;
};

/**
 * Comments policy of the video (Enabled = `1`, Disabled = `2`, Requires Approval = `3`)
 */
export type VideoCommentsPolicySet = 1 | 2 | 3;

export type VideoCommentsPolicyConstant = {
    id?: VideoCommentsPolicySet;
    label?: string;
};

export type BlockStatus = {
    accounts?: {
        [key: string]: {
            blockedByServer?: boolean;
            blockedByUser?: boolean;
        };
    };
    hosts?: {
        [key: string]: {
            blockedByServer?: boolean;
            blockedByUser?: boolean;
        };
    };
};

export type NsfwPolicy = 'display' | 'warn' | 'do_not_list';

/**
 *
 * NSFW flags (can be combined using bitwise or operator)
 * - `0` NONE
 * - `1` VIOLENT
 * - `2` EXPLICIT_SEX
 *
 */
export type NsfwFlag = 0 | 1 | 2 | 4;

/**
 * The user role (Admin = `0`, Moderator = `1`, User = `2`)
 */
export type UserRole = 0 | 1 | 2;

/**
 * Admin flags for the user (None = `0`, Bypass video blocklist = `1`)
 */
export type UserAdminFlags = 0 | 1;

/**
 * The live latency mode (Default = `1`, High latency = `2`, Small Latency = `3`)
 */
export type LiveVideoLatencyMode = 1 | 2 | 3;

export type LiveVideoReplaySettings = {
    privacy?: VideoPrivacySet;
};

export type VideoStateConstant = {
    /**
     * The video state:
     * - `1`: Published
     * - `2`: To transcode
     * - `3`: To import
     * - `4`: Waiting for live stream
     * - `5`: Live ended
     * - `6`: To move to an external storage (object storage...)
     * - `7`: Transcoding failed
     * - `8`: Moving to an external storage failed
     * - `9`: To edit using studio edition feature
     *
     */
    id?: 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9;
    label?: string;
};

/**
 * The user export state:
 * - `1`: Pending
 * - `2`: Processing
 * - `3`: Completed
 * - `4`: Errored
 *
 */
export type UserExportState = 1 | 2 | 3 | 4;

/**
 * The user import state:
 * - `1`: Pending
 * - `2`: Processing
 * - `3`: Completed
 * - `4`: Errored
 *
 */
export type UserImportState = 1 | 2 | 3 | 4;

/**
 * The abuse state (Pending = `1`, Rejected = `2`, Accepted = `3`)
 */
export type AbuseStateSet = 1 | 2 | 3;

export type AbuseStateConstant = {
    id?: AbuseStateSet;
    label?: string;
};

export type AbusePredefinedReasons = Array<'violentOrAbusive' | 'hatefulOrAbusive' | 'spamOrMisleading' | 'privacy' | 'rights' | 'serverRules' | 'thumbnails' | 'captions'>;

/**
 * Video resolution (`0`, `240`, `360`, `720`, `1080`, `1440` or `2160`)
 *
 * `0` is used as a special value for stillimage videos dedicated to audio, a.k.a. audio-only videos.
 *
 */
export type VideoResolutionSet = number;

/**
 * resolutions and their labels for the video
 */
export type VideoResolutionConstant = {
    id?: VideoResolutionSet;
    label?: string;
};

export type VideoScheduledUpdate = {
    privacy?: VideoPrivacySet;
    /**
     * When to update the video
     */
    updateAt: string;
};

export type AccountSummary = {
    id?: number;
    name?: string;
    displayName?: string;
    url?: string;
    host?: string;
    avatars?: Array<ActorImage>;
};

export type VideoChannelSummary = {
    id?: Id;
    name?: string;
    displayName?: string;
    url?: string;
    host?: string;
    avatars?: Array<ActorImage>;
};

export type PlaylistElement = {
    position?: number;
    startTimestamp?: number;
    stopTimestamp?: number;
    video?: Video | null;
};

export type VideoFile = {
    id?: Id;
    /**
     * magnet URI allowing to resolve the video via BitTorrent without a metainfo file
     */
    magnetUri?: string;
    resolution?: VideoResolutionConstant;
    /**
     * Video file size in bytes
     */
    size?: number;
    /**
     * Direct URL of the torrent file
     */
    torrentUrl?: string;
    /**
     * URL endpoint that transfers the torrent file as an attachment (so that the browser opens a download dialog)
     */
    torrentDownloadUrl?: string;
    /**
     * Direct URL of the video
     */
    fileUrl?: string;
    /**
     * Playlist URL of the file if it is owned by a playlist
     */
    playlistUrl?: string;
    /**
     * URL endpoint that transfers the video file as an attachment (so that the browser opens a download dialog)
     */
    fileDownloadUrl?: string;
    /**
     * Frames per second of the video file
     */
    fps?: number;
    /**
     * **PeerTube >= 6.1** Video stream width
     */
    width?: number;
    /**
     * **PeerTube >= 6.1** Video stream height
     */
    height?: number;
    /**
     * URL dereferencing the output of ffprobe on the file
     */
    metadataUrl?: string;
    /**
     * **PeerTube >= 6.2** The file container has an audio stream
     */
    hasAudio?: boolean;
    /**
     * **PeerTube >= 6.2** The file container has a video stream
     */
    hasVideo?: boolean;
    storage?: FileStorage;
};

export type VideoStreamingPlaylists = {
    id?: Id;
    /**
     * Playlist type:
     * - `1`: HLS
     *
     */
    type?: 1;
} & VideoStreamingPlaylistsHls;

export type VideoStreamingPlaylistsHls = {
    playlistUrl?: string;
    segmentsSha256Url?: string;
    /**
     * Video files associated to this playlist.
     *
     * The difference with the root `files` property is that these files are fragmented, so they can be used in this streaming playlist (HLS, etc.)
     *
     */
    files?: Array<VideoFile>;
    redundancies?: Array<{
        baseUrl?: string;
    }>;
};

export type VideoInfo = {
    id?: _heyapi_47_;
    uuid?: 2;
    name?: 3;
    state?: 4;
};

export type Video = {
    /**
     * object id for the video
     */
    id?: Id;
    /**
     * universal identifier for the video, that can be used across instances
     */
    uuid?: UuiDv4;
    shortUUID?: ShortUuid;
    isLive?: boolean;
    liveSchedules?: Array<LiveSchedule>;
    /**
     * time at which the video object was first drafted
     */
    createdAt?: string;
    /**
     * time at which the video was marked as ready for playback (with restrictions depending on `privacy`). Usually set after a `state` evolution.
     */
    publishedAt?: string;
    /**
     * last time the video's metadata was modified
     */
    updatedAt?: string;
    /**
     * used to represent a date of first publication, prior to the practical publication date of `publishedAt`
     */
    originallyPublishedAt?: string | null;
    /**
     * category in which the video is classified
     */
    category?: VideoConstantNumberCategory;
    /**
     * licence under which the video is distributed
     */
    licence?: VideoConstantNumberLicence;
    /**
     * main language used in the video
     */
    language?: VideoConstantStringLanguage;
    /**
     * privacy policy used to distribute the video
     */
    privacy?: VideoPrivacyConstant;
    /**
     * truncated description of the video, written in Markdown.
     *
     */
    truncatedDescription?: string | null;
    /**
     * duration of the video in seconds
     */
    duration?: number;
    /**
     * **PeerTube >= 6.1** Aspect ratio of the video stream
     */
    aspectRatio?: number | null;
    isLocal?: boolean;
    /**
     * title of the video
     */
    name?: string;
    thumbnailPath?: string;
    previewPath?: string;
    embedPath?: string;
    views?: number;
    likes?: number;
    dislikes?: number;
    /**
     * **PeerTube >= 7.2** Number of comments on the video
     */
    comments?: number;
    nsfw?: boolean;
    nsfwFlags?: NsfwFlag;
    /**
     * **PeerTube >= 7.2** More information about the sensitive content of the video
     */
    nsfwSummary?: string;
    waitTranscoding?: boolean | null;
    /**
     * represents the internal state of the video processing within the PeerTube instance
     */
    state?: VideoStateConstant;
    scheduledUpdate?: VideoScheduledUpdate | null;
    blacklisted?: boolean | null;
    blacklistedReason?: string | null;
    account?: AccountSummary;
    channel?: VideoChannelSummary;
    userHistory?: {
        currentTime?: number;
    } | null;
};

export type VideoDetails = Video & {
    /**
     * If the video is a live, you have the amount of current viewers
     */
    viewers?: number;
    /**
     * full description of the video, written in Markdown.
     *
     */
    description?: string | null;
    /**
     * A text tell the audience how to support the video creator
     */
    support?: string | null;
    channel?: VideoChannel;
    account?: Account;
    tags?: Array<string>;
    /**
     * Deprecated in 6.2, use commentsPolicy instead
     * @deprecated
     */
    commentsEnabled?: boolean;
    commentsPolicy?: VideoCommentsPolicyConstant;
    downloadEnabled?: boolean;
    /**
     * Latest input file update. Null if the file has never been replaced since the original upload
     */
    inputFileUpdatedAt?: string | null;
    trackerUrls?: Array<string>;
    /**
     * Web compatible video files. If Web Video is disabled on the server:
     *
     * - field will be empty
     * - video files will be found in `streamingPlaylists[].files` field
     *
     */
    files?: Array<VideoFile>;
    /**
     * HLS playlists/manifest files. If HLS is disabled on the server:
     *
     * - field will be empty
     * - video files will be found in `files` field
     *
     */
    streamingPlaylists?: Array<VideoStreamingPlaylists>;
};

export type FileRedundancyInformation = {
    id?: Id;
    fileUrl?: string;
    strategy?: 'manual' | 'most-views' | 'trending' | 'recently-added';
    size?: number;
    createdAt?: string;
    updatedAt?: string;
    expiresOn?: string;
};

export type VideoRedundancy = {
    id?: Id;
    name?: string;
    url?: string;
    uuid?: UuiDv4;
    redundancies?: {
        streamingPlaylists?: Array<FileRedundancyInformation>;
    };
};

export type CommentAutoTagPolicies = {
    /**
     * Auto tags that automatically set the comment in review state
     */
    review?: Array<string>;
};

export type AutomaticTagAvailable = {
    /**
     * Available auto tags that can be used to filter objects or set a comment in review state
     */
    available?: Array<{
        /**
         * tag name
         */
        name?: string;
        type?: 'core' | 'watched-words-list';
    }>;
};

export type VideoImportStateConstant = {
    /**
     * The video import state (Pending = `1`, Success = `2`, Failed = `3`)
     */
    id?: 1 | 2 | 3;
    label?: string;
};

export type VideoCreateImport = ({
    targetUrl: 5;
} | {
    magnetUri: 6;
} | {
    torrentfile: 7;
}) & VideoUploadRequestCommon;

export type VideoImport = {
    id?: Id;
    /**
     * remote URL where to find the import's source video
     */
    targetUrl?: string;
    /**
     * magnet URI allowing to resolve the import's source video
     */
    magnetUri?: string;
    /**
     * Torrent file containing only the video file
     */
    torrentfile?: Blob | File;
    torrentName?: string;
    state?: VideoImportStateConstant;
    error?: string;
    createdAt?: string;
    updatedAt?: string;
    video?: Video | null;
};

export type VideoImportsList = {
    total?: number;
    data?: Array<VideoImport>;
};

export type Abuse = {
    id?: Id;
    reason?: string;
    predefinedReasons?: AbusePredefinedReasons;
    reporterAccount?: Account;
    state?: AbuseStateConstant;
    moderationComment?: string;
    video?: {
        id?: number;
        uuid?: UuiDv4;
        shortUUID?: ShortUuid;
        name?: string;
        nsfw?: boolean;
        startAt?: string;
        endAt?: string;
        deleted?: boolean;
        blacklisted?: boolean;
        thumbnailPath?: string;
        channel?: VideoChannel;
    };
    createdAt?: string;
};

export type AbuseMessage = {
    id?: Id;
    message?: string;
    byModerator?: boolean;
    createdAt?: string;
    account?: AccountSummary;
};

export type VideoBlacklist = {
    id?: Id;
    videoId?: 8;
    createdAt?: string;
    updatedAt?: string;
    name?: string;
    uuid?: UuiDv4;
    description?: string;
    duration?: number;
    views?: number;
    likes?: number;
    dislikes?: number;
    nsfw?: boolean;
};

export type VideoPlaylist = {
    id?: Id;
    uuid?: UuiDv4;
    shortUUID?: ShortUuid;
    createdAt?: string;
    updatedAt?: string;
    description?: string;
    displayName?: string;
    isLocal?: boolean;
    videoLength?: number;
    thumbnailPath?: string;
    privacy?: VideoPlaylistPrivacyConstant;
    type?: VideoPlaylistTypeConstant;
    ownerAccount?: AccountSummary;
    videoChannel?: VideoChannelSummary;
    /**
     * Position of the playlist in the channel
     */
    videoChannelPosition?: number;
};

export type VideoComment = {
    id?: Id;
    url?: string;
    /**
     * Text of the comment
     */
    text?: string;
    threadId?: Id;
    inReplyToCommentId?: Id | null;
    videoId?: 8;
    createdAt?: string;
    updatedAt?: string;
    deletedAt?: string | null;
    isDeleted?: boolean;
    heldForReview?: boolean;
    totalRepliesFromVideoAuthor?: number;
    totalReplies?: number;
    account?: Account;
};

export type VideoCommentThreadTree = {
    comment?: VideoComment;
    children?: Array<VideoCommentThreadTree>;
};

export type VideoCommentForOwnerOrAdmin = {
    id?: Id;
    url?: 9;
    text?: 10;
    heldForReview?: 11;
    threadId?: Id;
    inReplyToCommentId?: 12;
    createdAt?: 13;
    updatedAt?: 14;
    account?: Account;
    video?: VideoInfo;
    automaticTags?: Array<string>;
};

export type Storyboard = {
    storyboardPath?: string;
    totalHeight?: number;
    totalWidth?: number;
    spriteHeight?: number;
    spriteWidth?: number;
    spriteDuration?: number;
};

export type VideoCaption = {
    language?: VideoConstantStringLanguage;
    captionPath?: string;
};

export type VideoChapters = {
    chapters?: {
        title?: string;
        timecode?: number;
    };
};

export type VideoSource = {
    /**
     * Deprecated in 6.1, use inputFilename instead
     * @deprecated
     */
    filename?: string;
    /**
     * Uploaded/imported filename
     */
    inputFilename?: string;
    /**
     * **PeerTube >= 6.1** If enabled by the admin, the video source file is kept on the server and can be downloaded by the owner
     */
    fileDownloadUrl?: string;
    /**
     * **PeerTube >= 6.1**
     */
    resolution?: VideoResolutionConstant;
    /**
     * **PeerTube >= 6.1** Video file size in bytes
     */
    size?: number;
    /**
     * **PeerTube >= 6.1** Frames per second of the video file
     */
    fps?: number;
    /**
     * **PeerTube >= 6.1** Video stream width
     */
    width?: number;
    /**
     * **PeerTube >= 6.1** Video stream height
     */
    height?: number;
    createdAt?: string;
};

export type ActorImage = {
    path?: string;
    width?: number;
    /**
     * **PeerTube >= 7.3** ImportVideosInChannelCreate:mage height
     */
    height?: number;
    createdAt?: string;
    updatedAt?: string;
};

export type ActorInfo = {
    id?: Id;
    name?: string;
    displayName?: string;
    host?: string;
    avatars?: Array<ActorImage>;
};

export type Actor = {
    id?: Id;
    url?: string;
    /**
     * immutable name of the actor, used to find or mention it
     */
    name?: Username;
    avatars?: Array<ActorImage>;
    /**
     * server on which the actor is resident
     */
    host?: string;
    /**
     * whether this actor's host allows redundancy of its videos
     */
    hostRedundancyAllowed?: boolean | null;
    /**
     * number of actors subscribed to by this actor, as seen by this instance
     */
    followingCount?: number;
    /**
     * number of followers of this actor, as seen by this instance
     */
    followersCount?: number;
    createdAt?: string;
    updatedAt?: string;
};

export type Account = Actor & {
    /**
     * object id for the user tied to this account
     */
    userId?: Id | null;
    /**
     * editable name of the account, displayed in its representations
     */
    displayName?: string;
    /**
     * text or bio displayed on the account's profile
     */
    description?: string | null;
};

export type UserViewingVideo = {
    /**
     * timestamp within the video, in seconds
     */
    currentTime: number;
    /**
     * Event since last viewing call:
     * * `seek` - If the user seeked the video
     *
     */
    viewEvent?: 'seek';
    /**
     * Optional param to represent the current viewer session. Used by the backend to properly count one view per session per video. PeerTube admin can configure the server to not trust this `sessionId` parameter but use the request IP address instead to identify a viewer.
     *
     */
    sessionId?: string;
    /**
     * Client software used to watch the video. For example "Firefox", "PeerTube Approval Android", etc.
     *
     */
    client?: string;
    /**
     * Device used to watch the video. For example "desktop", "mobile", "smarttv", etc.
     *
     */
    device?: VideoStatsUserAgentDevice;
    /**
     * Operating system used to watch the video. For example "Windows", "Ubuntu", etc.
     *
     */
    operatingSystem?: string;
};

export type VideoStatsOverall = {
    averageWatchTime?: number;
    totalWatchTime?: number;
    viewersPeak?: number;
    totalViewers?: number;
    viewersPeakDate?: string;
    countries?: Array<{
        isoCode?: string;
        viewers?: number;
    }>;
    subdivisions?: Array<{
        name?: string;
        viewers?: number;
    }>;
};

export type VideoStatsUserAgentDevice = 'console' | 'embedded' | 'mobile' | 'smarttv' | 'tablet' | 'wearable' | 'xr' | 'desktop';

export type VideoStatsUserAgent = {
    clients?: Array<{
        name?: string;
        viewers?: number;
    }>;
    devices?: Array<{
        name?: VideoStatsUserAgentDevice;
        viewers?: number;
    }>;
    operatingSystem?: Array<{
        name?: string;
        viewers?: number;
    }>;
};

export type VideoStatsRetention = {
    data?: Array<{
        second?: number;
        retentionPercent?: number;
    }>;
};

export type VideoStatsTimeserie = {
    data?: Array<{
        date?: string;
        value?: number;
    }>;
};

export type ServerConfig = {
    instance?: {
        name?: string;
        shortDescription?: string;
        defaultClientRoute?: string;
        isNSFW?: boolean;
        defaultNSFWPolicy?: string;
        serverCountry?: string;
        defaultLanguage?: string;
        support?: {
            text?: string;
        };
        social?: {
            externalLink?: string;
            mastodonLink?: string;
            blueskyLink?: string;
            xLink?: string;
        };
        customizations?: {
            javascript?: string;
            css?: string;
        };
        avatars?: Array<ActorImage>;
        banners?: Array<ActorImage>;
    };
    search?: {
        remoteUri?: {
            users?: boolean;
            anonymous?: boolean;
        };
    };
    plugin?: {
        registered?: Array<string>;
    };
    theme?: {
        registered?: Array<string>;
    };
    email?: {
        enabled?: boolean;
    };
    contactForm?: {
        enabled?: boolean;
    };
    serverVersion?: string;
    serverCommit?: string;
    signup?: {
        allowed?: boolean;
        allowedForCurrentIP?: boolean;
        requiresEmailVerification?: boolean;
    };
    transcoding?: {
        hls?: {
            enabled?: boolean;
        };
        web_videos?: {
            enabled?: boolean;
        };
        enabledResolutions?: Array<VideoResolutionSet>;
    };
    import?: {
        videos?: {
            http?: {
                enabled?: boolean;
            };
            torrent?: {
                enabled?: boolean;
            };
        };
        videoChannelSynchronization?: {
            enabled?: boolean;
        };
        users?: {
            enabled?: boolean;
        };
    };
    export?: {
        users?: {
            enabled?: boolean;
            /**
             * In milliseconds
             */
            exportExpiration?: number;
            /**
             * In bytes
             */
            maxUserVideoQuota?: number;
        };
    };
    autoBlacklist?: {
        videos?: {
            ofUsers?: {
                enabled?: boolean;
            };
        };
    };
    avatar?: {
        file?: {
            size?: {
                max?: number;
            };
        };
        extensions?: Array<string>;
    };
    video?: {
        image?: {
            extensions?: Array<string>;
            size?: {
                max?: number;
            };
        };
        file?: {
            extensions?: Array<string>;
        };
    };
    videoCaption?: {
        file?: {
            size?: {
                max?: number;
            };
            extensions?: Array<string>;
        };
    };
    user?: {
        /**
         * In bytes
         */
        videoQuota?: number;
        /**
         * In bytes
         */
        videoQuotaDaily?: number;
    };
    trending?: {
        videos?: {
            intervalDays?: number;
        };
    };
    tracker?: {
        enabled?: boolean;
    };
    followings?: {
        instance?: {
            autoFollowIndex?: {
                indexUrl?: string;
            };
        };
    };
    federation?: {
        enabled?: boolean;
    };
    homepage?: {
        enabled?: boolean;
    };
    /**
     * PeerTube >= 6.1
     */
    openTelemetry?: {
        metrics?: {
            enabled?: boolean;
            /**
             * Milliseconds
             */
            playbackStatsInterval?: number;
        };
    };
    /**
     * PeerTube >= 6.1
     */
    views?: {
        views?: {
            watchingInterval?: {
                /**
                 * Milliseconds
                 */
                anonymous?: number;
                /**
                 * Milliseconds
                 */
                users?: number;
            };
        };
    };
};

export type SendClientLog = {
    message: string;
    /**
     * URL of the current user page
     */
    url: string;
    level: 'error' | 'warn';
    /**
     * Stack trace of the error if there is one
     */
    stackTrace?: string;
    /**
     * User agent of the web browser that sends the message
     */
    userAgent?: string;
    /**
     * Additional information regarding this log
     */
    meta?: string;
};

export type ServerStats = {
    totalUsers?: number;
    totalDailyActiveUsers?: number;
    totalWeeklyActiveUsers?: number;
    totalMonthlyActiveUsers?: number;
    /**
     * **PeerTube >= 6.1** Value is null if the admin disabled total moderators stats
     */
    totalModerators?: number;
    /**
     * **PeerTube >= 6.1** Value is null if the admin disabled total admins stats
     */
    totalAdmins?: number;
    totalLocalVideos?: number;
    /**
     * Total video views made on the instance
     */
    totalLocalVideoViews?: number;
    /**
     * Total comments made by local users
     */
    totalLocalVideoComments?: number;
    totalLocalVideoFilesSize?: number;
    totalVideos?: number;
    totalVideoComments?: number;
    totalLocalVideoChannels?: number;
    totalLocalDailyActiveVideoChannels?: number;
    totalLocalWeeklyActiveVideoChannels?: number;
    totalLocalMonthlyActiveVideoChannels?: number;
    totalLocalPlaylists?: number;
    totalInstanceFollowers?: number;
    totalInstanceFollowing?: number;
    videosRedundancy?: Array<{
        strategy?: string;
        totalSize?: number;
        totalUsed?: number;
        totalVideoFiles?: number;
        totalVideos?: number;
    }>;
    totalActivityPubMessagesProcessed?: number;
    totalActivityPubMessagesSuccesses?: number;
    totalActivityPubMessagesErrors?: number;
    activityPubMessagesProcessedPerSecond?: number;
    totalActivityPubMessagesWaiting?: number;
    /**
     * **PeerTube >= 6.1** Value is null if the admin disabled registration requests stats
     */
    averageRegistrationRequestResponseTimeMs?: number;
    /**
     * **PeerTube >= 6.1** Value is null if the admin disabled registration requests stats
     */
    totalRegistrationRequestsProcessed?: number;
    /**
     * **PeerTube >= 6.1** Value is null if the admin disabled registration requests stats
     */
    totalRegistrationRequests?: number;
    /**
     * **PeerTube >= 6.1** Value is null if the admin disabled abuses stats
     */
    averageAbuseResponseTimeMs?: number;
    /**
     * **PeerTube >= 6.1** Value is null if the admin disabled abuses stats
     */
    totalAbusesProcessed?: number;
    /**
     * **PeerTube >= 6.1** Value is null if the admin disabled abuses stats
     */
    totalAbuses?: number;
};

export type ServerConfigAbout = {
    instance?: {
        name?: string;
        shortDescription?: string;
        description?: string;
        terms?: string;
        codeOfConduct?: string;
        hardwareInformation?: string;
        creationReason?: string;
        moderationInformation?: string;
        administrator?: string;
        maintenanceLifetime?: string;
        businessModel?: string;
        languages?: Array<string>;
        categories?: Array<number>;
        avatars?: Array<ActorImage>;
        banners?: Array<ActorImage>;
    };
};

export type ServerConfigCustom = {
    instance?: {
        name?: string;
        shortDescription?: string;
        description?: string;
        terms?: string;
        codeOfConduct?: string;
        creationReason?: string;
        moderationInformation?: string;
        administrator?: string;
        maintenanceLifetime?: string;
        businessModel?: string;
        hardwareInformation?: string;
        languages?: Array<string>;
        categories?: Array<number>;
        isNSFW?: boolean;
        defaultNSFWPolicy?: string;
        serverCountry?: string;
        support?: {
            text?: string;
        };
        social?: {
            externalLink?: string;
            mastodonLink?: string;
            blueskyLink?: string;
            xLink?: string;
        };
        defaultClientRoute?: string;
        customizations?: {
            javascript?: string;
            css?: string;
        };
    };
    theme?: {
        default?: string;
    };
    services?: {
        twitter?: {
            username?: string;
        };
    };
    cache?: {
        previews?: {
            size?: number;
        };
        captions?: {
            size?: number;
        };
    };
    signup?: {
        enabled?: boolean;
        limit?: number;
        requiresEmailVerification?: boolean;
    };
    admin?: {
        email?: string;
    };
    contactForm?: {
        enabled?: boolean;
    };
    /**
     * Settings that apply to new users, if registration is enabled
     */
    user?: {
        videoQuota?: number;
        videoQuotaDaily?: number;
    };
    /**
     * Settings pertaining to transcoding jobs
     */
    transcoding?: {
        enabled?: boolean;
        originalFile?: {
            keep?: boolean;
        };
        /**
         * Allow your users to upload .mkv, .mov, .avi, .wmv, .flv, .f4v, .3g2, .3gp, .mts, m2ts, .mxf, .nut videos
         */
        allowAdditionalExtensions?: boolean;
        /**
         * If a user uploads an audio file, PeerTube will create a video by merging the preview file and the audio file
         */
        allowAudioFiles?: boolean;
        /**
         * Amount of threads used by ffmpeg for 1 transcoding job
         */
        threads?: number;
        /**
         * Amount of transcoding jobs to execute in parallel
         */
        concurrency?: number;
        /**
         * New profiles can be added by plugins ; available in core PeerTube: 'default'.
         *
         */
        profile?: 'default';
        /**
         * Resolutions to transcode _new videos_ to
         */
        resolutions?: {
            '0p'?: boolean;
            '144p'?: boolean;
            '240p'?: boolean;
            '360p'?: boolean;
            '480p'?: boolean;
            '720p'?: boolean;
            '1080p'?: boolean;
            '1440p'?: boolean;
            '2160p'?: boolean;
        };
        /**
         * Web Video specific settings
         */
        web_videos?: {
            enabled?: boolean;
        };
        /**
         * HLS specific settings
         */
        hls?: {
            enabled?: boolean;
            splitAudioAndVideo?: boolean;
        };
    };
    import?: {
        videos?: {
            http?: {
                enabled?: boolean;
            };
            torrent?: {
                enabled?: boolean;
            };
        };
        video_channel_synchronization?: {
            enabled?: boolean;
        };
    };
    autoBlacklist?: {
        videos?: {
            ofUsers?: {
                enabled?: boolean;
            };
        };
    };
    followers?: {
        instance?: {
            enabled?: boolean;
            manualApproval?: boolean;
        };
    };
    storyboard?: {
        enabled?: boolean;
    };
    defaults?: {
        publish?: {
            downloadEnabled?: boolean;
            commentsPolicy?: VideoCommentsPolicySet;
            privacy?: VideoPrivacySet;
            licence?: VideoLicenceSet;
        };
        p2p?: {
            webapp?: {
                enabled?: boolean;
            };
            embed?: {
                enabled?: boolean;
            };
        };
        player?: {
            autoPlay?: boolean;
        };
    };
};

export type CustomHomepage = {
    content?: string;
};

export type Follow = {
    id?: Id;
    follower?: Actor;
    following?: Actor;
    /**
     * score reflecting the reachability of the actor, with steps of `10` and a base score of `1000`.
     */
    score?: number;
    state?: 'pending' | 'accepted';
    createdAt?: string;
    updatedAt?: string;
};

/**
 * Reason categories that help triage reports
 */
export type PredefinedAbuseReasons = Array<'violentOrAbusive' | 'hatefulOrAbusive' | 'spamOrMisleading' | 'privacy' | 'rights' | 'serverRules' | 'thumbnails' | 'captions'>;

export type Job = {
    id?: Id;
    state?: 'active' | 'completed' | 'failed' | 'waiting' | 'delayed';
    type?: 'activitypub-http-unicast' | 'activitypub-http-broadcast' | 'activitypub-http-fetcher' | 'activitypub-follow' | 'video-file-import' | 'video-transcoding' | 'email' | 'video-import' | 'videos-views-stats' | 'activitypub-refresher' | 'video-redundancy' | 'video-channel-import';
    data?: {
        [key: string]: unknown;
    };
    error?: {
        [key: string]: unknown;
    };
    createdAt?: string;
    finishedOn?: string;
    processedOn?: string;
};

export type AddUserResponse = {
    user?: {
        id?: Id;
        account?: {
            id?: Id;
        };
    };
};

export type VideoUploadRequestCommon = {
    /**
     * Video name
     */
    name: string;
    /**
     * Channel id that will contain this video
     */
    channelId: number;
    privacy?: VideoPrivacySet;
    category?: VideoCategorySet;
    licence?: VideoLicenceSet;
    language?: VideoLanguageSet;
    /**
     * Video description
     */
    description?: string;
    /**
     * Whether or not we wait transcoding before publish the video
     */
    waitTranscoding?: boolean;
    /**
     * **PeerTube >= 6.2** If enabled by the admin, automatically generate a subtitle of the video
     */
    generateTranscription?: boolean;
    /**
     * A text tell the audience how to support the video creator
     */
    support?: string;
    /**
     * Whether or not this video contains sensitive content
     */
    nsfw?: boolean;
    /**
     * More information about the sensitive content of the video
     */
    nsfwSummary?: unknown;
    nsfwFlags?: NsfwFlag;
    /**
     * Video tags (maximum 5 tags each between 2 and 30 characters)
     */
    tags?: Array<string>;
    /**
     * Deprecated in 6.2, use commentsPolicy instead
     * @deprecated
     */
    commentsEnabled?: boolean;
    commentsPolicy?: VideoCommentsPolicySet;
    /**
     * Enable or disable downloading for this video
     */
    downloadEnabled?: boolean;
    /**
     * Date when the content was originally published
     */
    originallyPublishedAt?: string;
    scheduleUpdate?: VideoScheduledUpdate;
    /**
     * Video thumbnail file
     */
    thumbnailfile?: Blob | File;
    /**
     * Video preview file
     */
    previewfile?: Blob | File;
    videoPasswords?: AddVideoPasswords;
};

export type VideoUploadRequestLegacy = VideoUploadRequestCommon & {
    /**
     * Video file
     */
    videofile: Blob | File;
};

export type VideoUploadRequestResumable = VideoUploadRequestCommon & {
    /**
     * Video filename including extension
     */
    filename: string;
    /**
     * Video thumbnail file
     */
    thumbnailfile?: Blob | File;
    /**
     * Video preview file
     */
    previewfile?: Blob | File;
};

export type VideoUploadResponse = {
    video?: {
        id?: 8;
        uuid?: UuiDv4;
        shortUUID?: ShortUuid;
    };
};

export type VideoReplaceSourceRequestResumable = {
    /**
     * Video filename including extension
     */
    filename?: string;
};

export type UserImportResumable = {
    /**
     * Archive filename including extension
     */
    filename?: string;
};

export type CommentThreadResponse = {
    /**
     * Total threads (included deleted ones) on this video
     */
    total?: number;
    /**
     * Total not-deleted threads (included deleted ones) on this video
     */
    totalNotDeletedComments?: number;
    data?: Array<VideoComment>;
};

export type CommentThreadPostResponse = {
    comment?: VideoComment;
};

export type VideoTokenResponse = {
    files?: {
        token?: string;
        expires?: string;
    };
};

export type VideoListResponse = {
    total?: number;
    data?: Array<Video>;
};

export type User = {
    account?: Account;
    /**
     * Automatically start playing the upcoming video after the currently playing video
     */
    autoPlayNextVideo?: boolean;
    /**
     * Automatically start playing the video on the playlist after the currently playing video
     */
    autoPlayNextVideoPlaylist?: boolean;
    /**
     * Automatically start playing the video on the watch page
     */
    autoPlayVideo?: boolean;
    blocked?: boolean;
    blockedReason?: string;
    createdAt?: string;
    /**
     * The user email
     */
    email?: string;
    /**
     * Has the user confirmed their email address?
     */
    emailVerified?: boolean;
    id?: Id;
    /**
     * Auth plugin to use to authenticate the user
     */
    pluginAuth?: string;
    lastLoginDate?: string;
    noInstanceConfigWarningModal?: boolean;
    noAccountSetupWarningModal?: boolean;
    noWelcomeModal?: boolean;
    nsfwPolicy?: NsfwPolicy;
    nsfwFlagsDisplayed?: NsfwFlag;
    nsfwFlagsHidden?: NsfwFlag;
    nsfwFlagsWarned?: NsfwFlag;
    nsfwFlagsBlurred?: NsfwFlag;
    role?: {
        id?: UserRole;
        label?: 'User' | 'Moderator' | 'Administrator';
    };
    /**
     * Theme enabled by this user
     */
    theme?: string;
    username?: Username;
    videoChannels?: Array<VideoChannel>;
    /**
     * The user video quota in bytes
     */
    videoQuota?: number;
    /**
     * The user daily video quota in bytes
     */
    videoQuotaDaily?: number;
    /**
     * Enable P2P in the player
     */
    p2pEnabled?: boolean;
};

export type UserWithStats = User & {
    /**
     * Count of videos published
     */
    videosCount?: number;
    /**
     * Count of reports/abuses of which the user is a target
     */
    abusesCount?: number;
    /**
     * Count of reports/abuses created by the user and accepted/acted upon by the moderation team
     */
    abusesAcceptedCount?: number;
    /**
     * Count of reports/abuses created by the user
     */
    abusesCreatedCount?: number;
    /**
     * Count of comments published
     */
    videoCommentsCount?: number;
};

export type AddUser = {
    username: Username;
    password: Password;
    /**
     * The user email
     */
    email: string;
    /**
     * The user video quota in bytes
     */
    videoQuota?: number;
    /**
     * The user daily video quota in bytes
     */
    videoQuotaDaily?: number;
    channelName?: UsernameChannel;
    role: UserRole;
    adminFlags?: UserAdminFlags;
};

export type UpdateUser = {
    /**
     * The updated email of the user
     */
    email?: 16;
    /**
     * Set the email as verified
     */
    emailVerified?: boolean;
    /**
     * The updated video quota of the user in bytes
     */
    videoQuota?: number;
    /**
     * The updated daily video quota of the user in bytes
     */
    videoQuotaDaily?: number;
    /**
     * The auth plugin to use to authenticate the user
     */
    pluginAuth?: string | null;
    role?: UserRole;
    adminFlags?: UserAdminFlags;
    password?: Password;
};

export type UpdateMe = {
    password?: Password;
    currentPassword?: Password;
    /**
     * new email used for login and service communications
     */
    email?: 16;
    /**
     * new name of the user in its representations
     */
    displayName?: string;
    /**
     * new NSFW display policy
     */
    nsfwPolicy?: 'true' | 'false' | 'both';
    nsfwFlagsDisplayed?: NsfwFlag;
    nsfwFlagsHidden?: NsfwFlag;
    nsfwFlagsWarned?: NsfwFlag;
    nsfwFlagsBlurred?: NsfwFlag;
    /**
     * whether to enable P2P in the player or not
     */
    p2pEnabled?: boolean;
    /**
     * new preference regarding playing videos automatically
     */
    autoPlayVideo?: boolean;
    /**
     * new preference regarding playing following videos automatically
     */
    autoPlayNextVideo?: boolean;
    /**
     * new preference regarding playing following playlist videos automatically
     */
    autoPlayNextVideoPlaylist?: boolean;
    /**
     * whether to keep track of watched history or not
     */
    videosHistoryEnabled?: boolean;
    /**
     * list of languages to filter videos down to
     */
    videoLanguages?: Array<string>;
    /**
     * default language for this user
     */
    language?: string;
    theme?: string;
    noInstanceConfigWarningModal?: boolean;
    noAccountSetupWarningModal?: boolean;
    noWelcomeModal?: boolean;
};

export type GetMeVideoRating = {
    id: Id;
    /**
     * Rating of the video
     */
    rating: 'like' | 'dislike' | 'none';
};

export type VideoRating = {
    video: Video;
    /**
     * Rating of the video
     */
    rating: 'like' | 'dislike' | 'none';
};

export type RegisterUser = {
    /**
     * immutable name of the user, used to find or mention its actor
     */
    username: Username;
    password: Password;
    /**
     * email of the user, used for login or service communications
     */
    email: string;
    /**
     * editable name of the user, displayed in its representations
     */
    displayName?: string;
    /**
     * channel base information used to create the first channel of the user
     */
    channel?: {
        name?: UsernameChannel;
        displayName?: string;
    };
};

export type UserRegistrationRequest = RegisterUser & {
    /**
     * reason for the user to register on the instance
     */
    registrationReason: string;
};

export type UserRegistrationAcceptOrReject = {
    /**
     * Moderation response to send to the user
     */
    moderationResponse: string;
    /**
     * Set it to true if you don't want PeerTube to send an email to the user
     */
    preventEmailDelivery?: boolean;
};

export type UserRegistration = {
    id?: Id;
    state?: {
        /**
         * The registration state (Pending = `1`, Rejected = `2`, Accepted = `3`)
         */
        id?: 1 | 2 | 3;
        label?: string;
    };
    registrationReason?: string;
    moderationResponse?: string | null;
    username?: string;
    email?: string;
    emailVerified?: boolean;
    accountDisplayName?: string;
    channelHandle?: string;
    channelDisplayName?: string;
    createdAt?: string;
    updatedAt?: string;
    /**
     * If the registration has been accepted, this is a partial user object created by the registration
     */
    user?: {
        id?: Id;
    } | null;
};

export type OAuthClient = {
    client_id?: string;
    client_secret?: string;
};

export type OAuthTokenPassword = OAuthClient & {
    grant_type: 'password';
    username: Username;
    password?: Password;
    /**
     * If you want to authenticate using an external authentication token you got from an auth plugin (like `peertube-plugin-auth-openid-connect` for example) instead of a password or a refresh token, provide it here.
     */
    externalAuthToken?: string;
};

export type OAuthTokenRefreshToken = OAuthClient & {
    grant_type: 'refresh_token';
    refresh_token: string;
};

export type VideoChannel = Actor & {
    /**
     * editable name of the channel, displayed in its representations
     */
    displayName?: string;
    description?: string | null;
    /**
     * text shown by default on all videos of this channel, to tell the audience how to support it
     */
    support?: string | null;
    isLocal?: boolean;
    updatedAt?: string;
    banners?: Array<ActorImage>;
    ownerAccount?: Account;
};

export type VideoChannelEdit = {
    /**
     * Channel display name
     */
    displayName?: unknown;
    /**
     * Channel description
     */
    description?: unknown;
    /**
     * How to support/fund the channel
     */
    support?: unknown;
};

export type VideoChannelCreate = VideoChannelEdit & {
    /**
     * username of the channel to create
     */
    name: UsernameChannel;
};

export type VideoChannelUpdate = VideoChannelEdit & {
    /**
     * Update the support field for all videos of this channel
     */
    bulkVideosSupportUpdate?: boolean;
};

export type VideoChannelList = {
    total?: number;
    data?: Array<VideoChannel & Actor>;
};

export type ImportVideosInChannelCreate = {
    externalChannelUrl: string;
    /**
     * If part of a channel sync process, specify its id to assign video imports to this channel synchronization
     */
    videoChannelSyncId?: number;
};

export type VideoChannelSync = {
    id?: Id;
    state?: {
        id?: number;
        label?: string;
    };
    externalChannelUrl?: string;
    createdAt?: string;
    lastSyncAt?: string | null;
    channel?: VideoChannel;
};

export type VideoChannelSyncList = {
    total?: number;
    data?: Array<VideoChannelSync>;
};

export type VideoChannelSyncCreate = {
    externalChannelUrl?: string;
    videoChannelId?: Id;
};

export type MrssPeerLink = {
    href?: string;
    type?: 'application/x-bittorrent';
};

export type MrssGroupContent = {
    url?: string;
    fileSize?: number;
    type?: string;
    framerate?: number;
    duration?: number;
    height?: number;
    lang?: string;
};

export type VideoCommentsForXml = Array<{
    link?: string;
    guid?: string;
    pubDate?: string;
    'content:encoded'?: string;
    'dc:creator'?: string;
}>;

export type VideosForXml = Array<{
    /**
     * video watch page URL
     */
    link?: string;
    /**
     * video canonical URL
     */
    guid?: string;
    /**
     * video publication date
     */
    pubDate?: string;
    /**
     * video description
     */
    description?: string;
    /**
     * video description
     */
    'content:encoded'?: string;
    /**
     * publisher user name
     */
    'dc:creator'?: string;
    /**
     * video category (MRSS)
     */
    'media:category'?: number;
    /**
     * see [media:community](https://www.rssboard.org/media-rss#media-community) (MRSS)
     */
    'media:community'?: {
        'media:statistics'?: {
            views?: number;
        };
    };
    'media:embed'?: {
        /**
         * video embed path, relative to the canonical URL domain (MRSS)
         */
        url?: string;
    };
    'media:player'?: {
        /**
         * video watch path, relative to the canonical URL domain (MRSS)
         */
        url?: string;
    };
    'media:thumbnail'?: {
        url?: string;
        height?: number;
        width?: number;
    };
    /**
     * see [media:title](https://www.rssboard.org/media-rss#media-title) (MRSS). We only use `plain` titles.
     */
    'media:title'?: string;
    'media:description'?: string;
    /**
     * see [media:rating](https://www.rssboard.org/media-rss#media-rating) (MRSS)
     */
    'media:rating'?: 'nonadult' | 'adult';
    /**
     * main streamable file for the video
     */
    enclosure?: {
        url?: string;
        type?: 'application/x-bittorrent';
        length?: number;
    };
    /**
     * list of streamable files for the video. see [media:peerLink](https://www.rssboard.org/media-rss#media-peerlink) and [media:content](https://www.rssboard.org/media-rss#media-content) or  (MRSS)
     */
    'media:group'?: Array<MrssPeerLink | MrssGroupContent>;
}>;

/**
 * Notification type. One of the following values, or a sum of multiple values:
 * - `0` NONE
 * - `1` WEB
 * - `2` EMAIL
 *
 */
export type NotificationSettingValue = number;

/**
 * Notification type. One of the following values:
 *
 * - `1` NEW_VIDEO_FROM_SUBSCRIPTION
 *
 * - `2` NEW_COMMENT_ON_MY_VIDEO
 *
 * - `3` NEW_ABUSE_FOR_MODERATORS
 *
 * - `4` BLACKLIST_ON_MY_VIDEO
 *
 * - `5` UNBLACKLIST_ON_MY_VIDEO
 *
 * - `6` MY_VIDEO_PUBLISHED
 *
 * - `7` MY_VIDEO_IMPORT_SUCCESS
 *
 * - `8` MY_VIDEO_IMPORT_ERROR
 *
 * - `9` NEW_USER_REGISTRATION
 *
 * - `10` NEW_FOLLOW
 *
 * - `11` COMMENT_MENTION
 *
 * - `12` VIDEO_AUTO_BLACKLIST_FOR_MODERATORS
 *
 * - `13` NEW_INSTANCE_FOLLOWER
 *
 * - `14` AUTO_INSTANCE_FOLLOWING
 *
 * - `15` ABUSE_STATE_CHANGE
 *
 * - `16` ABUSE_NEW_MESSAGE
 *
 * - `17` NEW_PLUGIN_VERSION
 *
 * - `18` NEW_PEERTUBE_VERSION
 *
 * - `19` MY_VIDEO_STUDIO_EDITION_FINISHED
 *
 * - `20` NEW_USER_REGISTRATION_REQUEST
 *
 * - `21` NEW_LIVE_FROM_SUBSCRIPTION
 *
 * - `22` MY_VIDEO_TRANSCRIPTION_GENERATED
 *
 */
export type NotificationType = 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9 | 10 | 11 | 12 | 13 | 14 | 15 | 16 | 17 | 18 | 19 | 20 | 21 | 22;

export type Notification = {
    id?: Id;
    type?: NotificationType;
    read?: boolean;
    video?: (VideoInfo & {
        channel?: ActorInfo;
    }) | null;
    videoImport?: {
        id?: Id;
        video?: VideoInfo | null;
        torrentName?: string | null;
        magnetUri?: 6;
        targetUri?: string | null;
    } | null;
    comment?: {
        id?: Id;
        threadId?: number;
        video?: VideoInfo;
        account?: ActorInfo;
        heldForReview?: boolean;
    } | null;
    videoAbuse?: {
        id?: Id;
        video?: VideoInfo;
    } | null;
    videoBlacklist?: {
        id?: Id;
        video?: VideoInfo;
    } | null;
    account?: ActorInfo | null;
    actorFollow?: {
        id?: Id;
        follower?: ActorInfo;
        state?: 'pending' | 'accepted';
        following?: {
            type?: 'account' | 'channel' | 'instance';
            name?: string;
            displayName?: string;
            host?: string;
        };
    } | null;
    createdAt?: string;
    updatedAt?: string;
};

export type NotificationListResponse = {
    total?: number;
    data?: Array<Notification>;
};

export type Plugin = {
    name?: string;
    /**
     * - `1`: PLUGIN
     * - `2`: THEME
     *
     */
    type?: 1 | 2;
    latestVersion?: string;
    version?: string;
    enabled?: boolean;
    uninstalled?: boolean;
    peertubeEngine?: string;
    description?: string;
    homepage?: string;
    settings?: {
        [key: string]: unknown;
    };
    createdAt?: string;
    updatedAt?: string;
};

export type PluginResponse = {
    total?: number;
    data?: Array<Plugin>;
};

export type LiveVideoUpdate = {
    saveReplay?: boolean;
    replaySettings?: LiveVideoReplaySettings;
    /**
     * User can stream multiple times in a permanent live
     */
    permanentLive?: boolean;
    /**
     * User can select live latency mode if enabled by the instance
     */
    latencyMode?: LiveVideoLatencyMode;
    schedules?: Array<LiveSchedule>;
};

export type LiveVideoResponse = {
    /**
     * Included in the response if an appropriate token is provided
     */
    rtmpUrl?: string;
    /**
     * Included in the response if an appropriate token is provided
     */
    rtmpsUrl?: string;
    /**
     * RTMP stream key to use to stream into this live video. Included in the response if an appropriate token is provided
     */
    streamKey?: string;
    saveReplay?: boolean;
    replaySettings?: LiveVideoReplaySettings;
    /**
     * User can stream multiple times in a permanent live
     */
    permanentLive?: boolean;
    /**
     * User can select live latency mode if enabled by the instance
     */
    latencyMode?: LiveVideoLatencyMode;
    schedules?: Array<LiveSchedule>;
};

export type LiveSchedule = {
    /**
     * Date when the stream is scheduled to air at
     */
    startAt?: string;
};

export type TokenSession = {
    id?: number;
    /**
     * Is this session the current one?
     */
    currentSession?: boolean;
    /**
     * Device used to login
     */
    loginDevice?: string;
    /**
     * IP address used to login
     */
    loginIP?: string;
    /**
     * Date of the login
     */
    loginDate?: string;
    lastActivityDevice?: string;
    lastActivityIP?: string;
    lastActivityDate?: string;
    createdAt?: string;
};

export type RequestTwoFactorResponse = {
    otpRequest?: {
        /**
         * The token to send to confirm this request
         */
        requestToken?: string;
        /**
         * The OTP secret
         */
        secret?: string;
        /**
         * The OTP URI
         */
        uri?: string;
    };
};

export type VideoStudioCreateTask = Array<{
    name?: 'cut';
    options?: {
        start?: number;
        end?: number;
    };
} | {
    name?: 'add-intro';
    options?: {
        file?: Blob | File;
    };
} | {
    name?: 'add-outro';
    options?: {
        file?: Blob | File;
    };
} | {
    name?: 'add-watermark';
    options?: {
        file?: Blob | File;
    };
}>;

export type LiveVideoSessionResponse = {
    id?: number;
    /**
     * Start date of the live session
     */
    startDate?: string;
    /**
     * End date of the live session
     */
    endDate?: string | null;
    /**
     * Error type if an error occurred during the live session:
     * - `1`: Bad socket health (transcoding is too slow)
     * - `2`: Max duration exceeded
     * - `3`: Quota exceeded
     * - `4`: Quota FFmpeg error
     * - `5`: Video has been blacklisted during the live
     *
     */
    error?: 1 | 2 | 3 | 4 | 5;
    /**
     * Video replay information
     */
    replayVideo?: {
        id?: number;
        uuid?: UuiDv4;
        shortUUID?: ShortUuid;
    };
};

export type PlaybackMetricCreate = {
    playerMode: 'p2p-media-loader' | 'web-video';
    /**
     * Current player video resolution
     */
    resolution?: number;
    /**
     * Current player video fps
     */
    fps?: number;
    p2pEnabled: boolean;
    /**
     * P2P peers connected (doesn't include WebSeed peers)
     */
    p2pPeers?: number;
    /**
     * How many resolution changes occurred since the last metric creation
     */
    resolutionChanges: number;
    /**
     * How many times buffer has been stalled since the last metric creation
     */
    bufferStalled?: number;
    /**
     * How many errors occurred since the last metric creation
     */
    errors: number;
    /**
     * How many bytes were downloaded with P2P since the last metric creation
     */
    downloadedBytesP2P: number;
    /**
     * How many bytes were downloaded with HTTP since the last metric creation
     */
    downloadedBytesHTTP: number;
    /**
     * How many bytes were uploaded with P2P since the last metric creation
     */
    uploadedBytesP2P: number;
    videoId: Id | UuiDv4 | ShortUuid;
};

export type RunnerRegistrationToken = {
    id?: number;
    registrationToken?: string;
    createdAt?: string;
    updatedAt?: string;
    registeredRunnersCount?: number;
};

export type Runner = {
    id?: number;
    name?: string;
    description?: string;
    ip?: string;
    updatedAt?: string;
    createdAt?: string;
    lastContact?: string;
};

export type RunnerJobType = 'vod-web-video-transcoding' | 'vod-hls-transcoding' | 'vod-audio-merge-transcoding' | 'live-rtmp-hls-transcoding';

/**
 * The runner job state:
 * - `1` Pending
 * - `2` Processing
 * - `3` Completed
 * - `4` Errored
 * - `5` Waiting for a parent job
 * - `6` Cancelled
 * - `7` Parent had an error
 * - `8` Parent has been cancelled
 *
 */
export type RunnerJobState = 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8;

export type RunnerJobStateConstant = {
    id?: RunnerJobState;
    label?: string;
};

export type RunnerJobPayload = {
    input?: {
        videoFileUrl?: string;
    };
    output?: {
        resolution?: number;
        fps?: number;
    };
} | {
    input?: {
        videoFileUrl?: string;
    };
    output?: {
        resolution?: number;
        fps?: number;
    };
} | {
    input?: {
        audioFileUrl?: string;
        previewFileUrl?: string;
    };
    output?: {
        resolution?: number;
        fps?: number;
    };
};

export type RunnerJob = {
    uuid?: UuiDv4;
    type?: RunnerJobType;
    state?: RunnerJobStateConstant;
    payload?: RunnerJobPayload;
    /**
     * Number of times a remote runner failed to process this job. After too many failures, the job in "error" state
     */
    failures?: number;
    /**
     * Error message if the job is errored
     */
    error?: string | null;
    /**
     * Percentage progress
     */
    progress?: number;
    /**
     * Job priority (less has more priority)
     */
    priority?: number;
    updatedAt?: string;
    createdAt?: string;
    startedAt?: string;
    finishedAt?: string;
    /**
     * If job has a parent job
     */
    parent?: {
        type?: RunnerJobType;
        state?: RunnerJobStateConstant;
        uuid?: UuiDv4;
    } | null;
    /**
     * If job is associated to a runner
     */
    runner?: {
        id?: number;
        name?: string;
        description?: string;
    } | null;
};

export type RunnerJobAdmin = RunnerJob & {
    privatePayload?: {
        [key: string]: unknown;
    };
};

export type WatchedWordsLists = {
    id?: Id;
    listName?: string;
    words?: Array<string>;
    updatedAt?: string;
    createdAt?: string;
};

export type VideoPassword = {
    id?: Id;
    password?: string;
    videoId?: Id;
};

export type VideoPasswordList = {
    total?: number;
    data?: Array<VideoPassword>;
};

export type AddVideoPasswords = Array<17>;

/**
 * The player theme to use
 */
export type PlayerTheme = 'galaxy' | 'lucide';

/**
 * Player theme setting for a channel:
 * - `instance-default` Use the instance default theme
 * - `galaxy` Use the galaxy theme
 * - `lucide` Use the lucide theme
 *
 */
export type PlayerThemeChannelSetting = 'instance-default' | 'galaxy' | 'lucide';

/**
 * Player theme setting for a video:
 * - `channel-default` Use the channel default theme
 * - `instance-default` Use the instance default theme
 * - `galaxy` Use the galaxy theme
 * - `lucide` Use the lucide theme
 *
 */
export type PlayerThemeVideoSetting = 'channel-default' | 'instance-default' | 'galaxy' | 'lucide';

/**
 * Player settings for a video
 */
export type PlayerVideoSettings = {
    theme?: PlayerThemeVideoSetting;
};

/**
 * Player settings for a channel
 */
export type PlayerChannelSettings = {
    theme?: PlayerThemeChannelSetting;
};

/**
 * Player settings update for a video
 */
export type PlayerVideoSettingsUpdate = {
    theme: PlayerThemeVideoSetting;
};

/**
 * Player settings update for a channel
 */
export type PlayerChannelSettingsUpdate = {
    theme: PlayerThemeChannelSetting;
};

/**
 * The file storage type:
 * - `0` File system
 * - `1` Object storage
 *
 */
export type FileStorage = 0 | 1;

/**
 * Offset used to paginate results
 */
export type Start = number;

/**
 * Number of items to return
 */
export type Count = number;

/**
 * Sort column
 */
export type Sort = string;

/**
 * Plain text search, applied to various parts of the model depending on endpoint
 */
export type Search = string;

/**
 * If the administrator enabled search index support, you can override the default search target.
 *
 * **Warning**: If you choose to make an index search, PeerTube will get results from a third party service. It means the instance may not yet know the objects you fetched. If you want to load video/channel information:
 * * If the current user has the ability to make a remote URI search (this information is available in the config endpoint),
 * then reuse the search API to make a search using the object URI so PeerTube instance fetches the remote object and fill its database.
 * After that, you can use the classic REST API endpoints to fetch the complete object or interact with it
 * * If the current user doesn't have the ability to make a remote URI search, then redirect the user on the origin instance or fetch
 * the data from the origin instance API
 *
 */
export type SearchTarget = 'local' | 'search-index';

export type MySubscriptionSort = '-id' | '-createdAt' | '-channelUpdatedAt';

/**
 * Sort videos by criteria (prefixing with `-` means `DESC` order):
 * * `hot` - Adaptation of Reddit "hot" algorithm taking into account video views, likes, dislikes and comments and publication date
 * * `best` - Same than `hot`, but also takes into account user video history
 * * `trending` - Sort videos by recent views ("recent" is defined by the admin)
 * * `views` - Sort videos using their `views` counter
 * * `publishedAt` - Sort by video publication date (when it became publicly available)
 *
 */
export type VideosSort = 'name' | '-duration' | '-createdAt' | '-publishedAt' | '-views' | '-likes' | '-comments' | '-trending' | '-hot' | '-best';

/**
 * Sort videos by criteria (prefixing with `-` means `DESC` order):
 *
 */
export type VideosSearchSort = 'name' | '-duration' | '-createdAt' | '-publishedAt' | '-views' | '-likes' | '-match';

/**
 * Sort comments by criteria
 */
export type CommentsSort = '-createdAt' | '-totalReplies';

/**
 * Sort blocklists by criteria
 */
export type BlacklistsSort = '-id' | 'name' | '-duration' | '-views' | '-likes' | '-dislikes' | '-uuid' | '-createdAt';

/**
 * Plain text search that will match with user usernames or emails
 */
export type UsersSearch = string;

/**
 * Filter results down to (un)banned users
 */
export type UsersBlocked = boolean;

/**
 * Sort users by criteria
 */
export type UsersSort = '-id' | '-username' | '-createdAt';

/**
 * Sort abuses by criteria
 */
export type AbusesSort = '-id' | '-createdAt' | '-state';

/**
 * Sort abuses by criteria
 */
export type VideoRedundanciesSort = 'name';

/**
 * Sort followers by criteria
 */
export type FollowersSort = 'createdAt';

/**
 * Sort registration tokens by criteria
 */
export type RegistrationTokenSort = 'createdAt';

/**
 * Sort runners by criteria
 */
export type RunnerSort = 'createdAt';

/**
 * Sort runner jobs by criteria
 */
export type RunnerJobSort = 'updatedAt' | 'createdAt' | 'priority' | 'state' | 'progress';

/**
 * The username or handle of the account
 */
export type Name = string;

/**
 * Entity id
 */
export type Id2 = Id;

/**
 * Token session Id
 */
export type TokenSessionId = Id;

/**
 * User id
 */
export type UserId = Id;

/**
 * Registration ID
 */
export type RegistrationId = Id;

/**
 * The object id, uuid or short uuid
 */
export type IdOrUuid = Id | UuiDv4 | ShortUuid;

/**
 * Playlist id
 */
export type PlaylistId = Id;

/**
 * Playlist element id
 */
export type PlaylistElementId = Id;

/**
 * Abuse id
 */
export type AbuseId = Id;

/**
 * Abuse message id
 */
export type AbuseMessageId = Id;

/**
 * The caption language
 */
export type CaptionLanguage = VideoLanguageSet;

/**
 * The video channel handle
 */
export type ChannelHandle = string;

/**
 * Channel Sync id
 */
export type ChannelSyncId = Id;

/**
 * The subscription handle
 */
export type SubscriptionHandle = string;

/**
 * The thread id (root comment id)
 */
export type ThreadId = number;

/**
 * The comment id
 */
export type CommentId = Id;

/**
 * whether or not the video is a live
 */
export type IsLive = boolean;

/**
 * whether or not include live that are scheduled for later
 */
export type IncludeScheduledLive = boolean;

/**
 * category id of the video (see [/videos/categories](#operation/getCategories))
 */
export type CategoryOneOf = VideoCategorySet | Array<VideoCategorySet>;

/**
 * tag(s) of the video
 */
export type TagsOneOf = string | Array<string>;

/**
 * tag(s) of the video, where all should be present in the video
 */
export type TagsAllOf = string | Array<string>;

/**
 * language id of the video (see [/videos/languages](#operation/getLanguages)). Use `_unknown` to filter on videos that don't have a video language
 */
export type LanguageOneOf = VideoLanguageSet | Array<VideoLanguageSet>;

/**
 * **PeerTube >= 6.2** **Admins and moderators only** filter on videos that contain one of these automatic tags
 */
export type AutoTagOneOfVideo = string | Array<string>;

/**
 * **PeerTube >= 7.2** Filter on videos that are published by a channel with one of these names
 */
export type ChannelNameOneOf = string | Array<string>;

/**
 * **PeerTube >= 6.2** filter on comments that contain one of these automatic tags
 */
export type AutoTagOneOfComment = string | Array<string>;

/**
 * only display comments that are held for review
 */
export type IsHeldForReview = boolean;

/**
 * licence id of the video (see [/videos/licences](#operation/getLicences))
 */
export type LicenceOneOf = VideoLicenceSet | Array<VideoLicenceSet>;

/**
 * if you don't need the `total` in the response
 */
export type SkipCount = 'true' | 'false';

/**
 * whether to include nsfw videos, if any
 */
export type Nsfw = 'true' | 'false';

export type NsfwFlagsIncluded = NsfwFlag;

export type NsfwFlagsExcluded = NsfwFlag;

/**
 * **PeerTube >= 4.0** Display only local or remote objects
 */
export type IsLocal = boolean;

/**
 * **PeerTube >= 4.0** Display only videos that have HLS files
 */
export type HasHlsFiles = boolean;

/**
 * **PeerTube >= 6.0** Display only videos that have Web Video files
 */
export type HasWebVideoFiles = boolean;

/**
 * **PeerTube >= 4.0** Display only videos in this specific privacy/privacies
 */
export type PrivacyOneOf = VideoPrivacySet;

/**
 * Whether or not to exclude videos that are in the user's video history
 */
export type ExcludeAlreadyWatched = boolean;

/**
 * Find elements with specific UUIDs
 */
export type Uuids = unknown;

/**
 * Find elements owned by this host
 */
export type Host = string;

/**
 * Find elements with these handles
 */
export type Handles = unknown;

/**
 * **Only administrators and moderators can use this parameter**
 *
 * Include additional videos in results (can be combined using bitwise or operator)
 * - `0` NONE
 * - `1` NOT_PUBLISHED_STATE
 * - `2` BLACKLISTED
 * - `4` BLOCKED_OWNER
 * - `8` FILES
 * - `16` CAPTIONS
 * - `32` VIDEO SOURCE
 *
 */
export type Include = 0 | 1 | 2 | 4 | 8 | 16 | 32;

/**
 * list of uris to check if each is part of the user subscriptions
 */
export type SubscriptionsUris = Array<string>;

/**
 * name of the plugin/theme on npmjs.com or in its package.json
 */
export type NpmName = string;

/**
 * job type
 */
export type JobType = 'activitypub-follow' | 'activitypub-http-broadcast' | 'activitypub-http-fetcher' | 'activitypub-http-unicast' | 'email' | 'video-transcoding' | 'video-file-import' | 'video-import' | 'videos-views-stats' | 'activitypub-refresher' | 'video-redundancy' | 'video-live-ending' | 'video-channel-import';

export type FollowState = 'pending' | 'accepted';

export type ActorType = 'Person' | 'Application' | 'Group' | 'Service' | 'Organization';

/**
 * Filename
 */
export type StaticFilename = string;

/**
 * Video file token [generated](#operation/requestVideoToken) by PeerTube so you don't need to provide an OAuth token in the request header.
 */
export type VideoFileToken = string;

/**
 * Ask the server to reinject videoFileToken in URLs in m3u8 playlist
 */
export type ReinjectVideoFileToken = boolean;

export type VideoPlaylistType = VideoPlaylistTypeSet;

export type RegistrationTokenId = number;

export type RunnerId = number;

export type JobUuid = UuiDv4;

/**
 * The video password id
 */
export type VideoPasswordId = Id;

/**
 * Display only objects of local or remote videos
 */
export type OnLocalVideo = boolean;

/**
 * Limit results on this specific video channel
 */
export type VideoChannelId = number;

/**
 * Limit results on this specific video
 */
export type VideoId = number;

/**
 * Filter comments by searching on the video
 */
export type SearchVideoForComments = string;

/**
 * Filter comments by searching on the account
 */
export type SearchAccountForComments = string;

/**
 * Required on password protected video
 */
export type VideoPasswordHeader = string;

/**
 * Number of bytes that will be uploaded in subsequent requests. Set this value to the size of the file you are uploading.
 */
export type ResumableUploadInitContentLengthHeader = number;

/**
 * MIME type of the file that you are uploading. Depending on your instance settings, acceptable values might vary.
 */
export type ResumableUploadInitContentTypeHeader = string;

/**
 * Specifies the bytes in the file that the request is uploading.
 *
 * For example, a value of `bytes 0-262143/1000000` shows that the request is sending the first
 * 262144 bytes (256 x 1024) in a 2,469,036 byte file.
 *
 */
export type ResumableUploadChunkContentRangeHeader = string;

/**
 * Size of the chunk that the request is sending.
 *
 * Remember that larger chunks are more efficient. PeerTube's web client uses chunks varying from
 * 1048576 bytes (~1MB) and increases or reduces size depending on connection health.
 *
 */
export type ResumableUploadChunkContentLengthHeader = number;

/**
 * Created session id to proceed with. If you didn't send chunks in the last hour, it is
 * not valid anymore and you need to initialize a new upload.
 *
 */
export type ResumableUploadId = string;

export type LogoTypeParam = 'favicon' | 'header-wide' | 'header-square' | 'opengraph';

export type GetStaticWebVideosByFilenameData = {
    body?: never;
    path: {
        /**
         * Filename
         */
        filename: string;
    };
    query?: never;
    url: '/static/web-videos/{filename}';
};

export type GetStaticWebVideosByFilenameErrors = {
    /**
     * not found
     */
    404: unknown;
};

export type GetStaticWebVideosByFilenameResponses = {
    /**
     * successful operation
     */
    200: unknown;
};

export type GetStaticWebVideosPrivateByFilenameData = {
    body?: never;
    path: {
        /**
         * Filename
         */
        filename: string;
    };
    query?: {
        /**
         * Video file token [generated](#operation/requestVideoToken) by PeerTube so you don't need to provide an OAuth token in the request header.
         */
        videoFileToken?: string;
    };
    url: '/static/web-videos/private/{filename}';
};

export type GetStaticWebVideosPrivateByFilenameErrors = {
    /**
     * invalid auth
     */
    403: unknown;
    /**
     * not found
     */
    404: unknown;
};

export type GetStaticWebVideosPrivateByFilenameResponses = {
    /**
     * successful operation
     */
    200: unknown;
};

export type GetStaticStreamingPlaylistsHlsByFilenameData = {
    body?: never;
    path: {
        /**
         * Filename
         */
        filename: string;
    };
    query?: never;
    url: '/static/streaming-playlists/hls/{filename}';
};

export type GetStaticStreamingPlaylistsHlsByFilenameErrors = {
    /**
     * invalid auth
     */
    403: unknown;
    /**
     * not found
     */
    404: unknown;
};

export type GetStaticStreamingPlaylistsHlsByFilenameResponses = {
    /**
     * successful operation
     */
    200: unknown;
};

export type GetStaticStreamingPlaylistsHlsPrivateByFilenameData = {
    body?: never;
    path: {
        /**
         * Filename
         */
        filename: string;
    };
    query?: {
        /**
         * Video file token [generated](#operation/requestVideoToken) by PeerTube so you don't need to provide an OAuth token in the request header.
         */
        videoFileToken?: string;
        /**
         * Ask the server to reinject videoFileToken in URLs in m3u8 playlist
         */
        reinjectVideoFileToken?: boolean;
    };
    url: '/static/streaming-playlists/hls/private/{filename}';
};

export type GetStaticStreamingPlaylistsHlsPrivateByFilenameErrors = {
    /**
     * invalid auth
     */
    403: unknown;
    /**
     * not found
     */
    404: unknown;
};

export type GetStaticStreamingPlaylistsHlsPrivateByFilenameResponses = {
    /**
     * successful operation
     */
    200: unknown;
};

export type GetDownloadVideosGenerateByVideoIdData = {
    body?: never;
    path: {
        /**
         * The video id
         */
        videoId: 8;
    };
    query: {
        /**
         * streams of video files to mux in the output
         */
        videoFileIds: Array<number>;
        /**
         * Video file token [generated](#operation/requestVideoToken) by PeerTube so you don't need to provide an OAuth token in the request header.
         */
        videoFileToken?: string;
    };
    url: '/download/videos/generate/{videoId}';
};

export type GetDownloadVideosGenerateByVideoIdResponses = {
    /**
     * successful operation
     */
    200: unknown;
};

export type GetSyndicatedCommentsData = {
    body?: never;
    path: {
        /**
         * format expected (we focus on making `rss` the most feature-rich ; it serves [Media RSS](https://www.rssboard.org/media-rss))
         */
        format: 'xml' | 'rss' | 'rss2' | 'atom' | 'atom1' | 'json' | 'json1';
    };
    query?: {
        /**
         * limit listing comments to a specific video
         */
        videoId?: string;
        /**
         * limit listing comments to videos of a specific account
         */
        accountId?: string;
        /**
         * limit listing comments to videos of a specific account
         */
        accountName?: string;
        /**
         * limit listing comments to videos of a specific video channel
         */
        videoChannelId?: string;
        /**
         * limit listing comments to videos of a specific video channel
         */
        videoChannelName?: string;
    };
    url: '/feeds/video-comments.{format}';
};

export type GetSyndicatedCommentsErrors = {
    /**
     * Arises when:
     * - videoId filter is mixed with a channel filter
     *
     */
    400: unknown;
    /**
     * video, video channel or account not found
     */
    404: unknown;
    /**
     * accept header unsupported
     */
    406: unknown;
};

export type GetSyndicatedCommentsResponses = {
    /**
     * successful operation
     */
    200: {
        [key: string]: unknown;
    };
};

export type GetSyndicatedCommentsResponse = GetSyndicatedCommentsResponses[keyof GetSyndicatedCommentsResponses];

export type GetSyndicatedVideosData = {
    body?: never;
    path: {
        /**
         * format expected (we focus on making `rss` the most feature-rich ; it serves [Media RSS](https://www.rssboard.org/media-rss))
         */
        format: 'xml' | 'rss' | 'rss2' | 'atom' | 'atom1' | 'json' | 'json1';
    };
    query?: {
        /**
         * limit listing to a specific account
         */
        accountId?: string;
        /**
         * limit listing to a specific account
         */
        accountName?: string;
        /**
         * limit listing to a specific video channel
         */
        videoChannelId?: string;
        /**
         * limit listing to a specific video channel
         */
        videoChannelName?: string;
        /**
         * Sort column
         */
        sort?: string;
        /**
         * whether to include nsfw videos, if any
         */
        nsfw?: 'true' | 'false';
        /**
         * **PeerTube >= 4.0** Display only local or remote objects
         */
        isLocal?: boolean;
        /**
         * **Only administrators and moderators can use this parameter**
         *
         * Include additional videos in results (can be combined using bitwise or operator)
         * - `0` NONE
         * - `1` NOT_PUBLISHED_STATE
         * - `2` BLACKLISTED
         * - `4` BLOCKED_OWNER
         * - `8` FILES
         * - `16` CAPTIONS
         * - `32` VIDEO SOURCE
         *
         */
        include?: 0 | 1 | 2 | 4 | 8 | 16 | 32;
        /**
         * **PeerTube >= 4.0** Display only videos in this specific privacy/privacies
         */
        privacyOneOf?: VideoPrivacySet;
        /**
         * **PeerTube >= 4.0** Display only videos that have HLS files
         */
        hasHLSFiles?: boolean;
        /**
         * **PeerTube >= 6.0** Display only videos that have Web Video files
         */
        hasWebVideoFiles?: boolean;
    };
    url: '/feeds/videos.{format}';
};

export type GetSyndicatedVideosErrors = {
    /**
     * video channel or account not found
     */
    404: unknown;
    /**
     * accept header unsupported
     */
    406: unknown;
};

export type GetSyndicatedVideosResponses = {
    /**
     * successful operation
     */
    200: {
        [key: string]: unknown;
    };
};

export type GetSyndicatedVideosResponse = GetSyndicatedVideosResponses[keyof GetSyndicatedVideosResponses];

export type GetSyndicatedSubscriptionVideosData = {
    body?: never;
    path: {
        /**
         * format expected (we focus on making `rss` the most feature-rich ; it serves [Media RSS](https://www.rssboard.org/media-rss))
         */
        format: 'xml' | 'rss' | 'rss2' | 'atom' | 'atom1' | 'json' | 'json1';
    };
    query: {
        /**
         * limit listing to a specific account
         */
        accountId: string;
        /**
         * private token allowing access
         */
        token: string;
        /**
         * Sort column
         */
        sort?: string;
        /**
         * whether to include nsfw videos, if any
         */
        nsfw?: 'true' | 'false';
        /**
         * **PeerTube >= 4.0** Display only local or remote objects
         */
        isLocal?: boolean;
        /**
         * **Only administrators and moderators can use this parameter**
         *
         * Include additional videos in results (can be combined using bitwise or operator)
         * - `0` NONE
         * - `1` NOT_PUBLISHED_STATE
         * - `2` BLACKLISTED
         * - `4` BLOCKED_OWNER
         * - `8` FILES
         * - `16` CAPTIONS
         * - `32` VIDEO SOURCE
         *
         */
        include?: 0 | 1 | 2 | 4 | 8 | 16 | 32;
        /**
         * **PeerTube >= 4.0** Display only videos in this specific privacy/privacies
         */
        privacyOneOf?: VideoPrivacySet;
        /**
         * **PeerTube >= 4.0** Display only videos that have HLS files
         */
        hasHLSFiles?: boolean;
        /**
         * **PeerTube >= 6.0** Display only videos that have Web Video files
         */
        hasWebVideoFiles?: boolean;
    };
    url: '/feeds/subscriptions.{format}';
};

export type GetSyndicatedSubscriptionVideosErrors = {
    /**
     * accept header unsupported
     */
    406: unknown;
};

export type GetSyndicatedSubscriptionVideosResponses = {
    /**
     * successful operation
     */
    200: {
        [key: string]: unknown;
    };
};

export type GetSyndicatedSubscriptionVideosResponse = GetSyndicatedSubscriptionVideosResponses[keyof GetSyndicatedSubscriptionVideosResponses];

export type GetVideosPodcastFeedData = {
    body?: never;
    path?: never;
    query: {
        /**
         * Limit listing to a specific video channel
         */
        videoChannelId: string;
    };
    url: '/feeds/podcast/videos.xml';
};

export type GetVideosPodcastFeedErrors = {
    /**
     * video channel not found
     */
    404: unknown;
};

export type GetVideosPodcastFeedResponses = {
    /**
     * successful operation
     */
    200: unknown;
};

export type GetAccountData = {
    body?: never;
    path: {
        /**
         * The username or handle of the account
         */
        name: string;
    };
    query?: never;
    url: '/api/v1/accounts/{name}';
};

export type GetAccountErrors = {
    /**
     * account not found
     */
    404: unknown;
};

export type GetAccountResponses = {
    /**
     * successful operation
     */
    200: Account;
};

export type GetAccountResponse = GetAccountResponses[keyof GetAccountResponses];

export type GetAccountVideosData = {
    body?: never;
    path: {
        /**
         * The username or handle of the account
         */
        name: string;
    };
    query?: {
        /**
         * Offset used to paginate results
         */
        start?: number;
        /**
         * Number of items to return
         */
        count?: number;
        /**
         * if you don't need the `total` in the response
         */
        skipCount?: 'true' | 'false';
        /**
         * Sort videos by criteria (prefixing with `-` means `DESC` order):
         * * `hot` - Adaptation of Reddit "hot" algorithm taking into account video views, likes, dislikes and comments and publication date
         * * `best` - Same than `hot`, but also takes into account user video history
         * * `trending` - Sort videos by recent views ("recent" is defined by the admin)
         * * `views` - Sort videos using their `views` counter
         * * `publishedAt` - Sort by video publication date (when it became publicly available)
         *
         */
        sort?: 'name' | '-duration' | '-createdAt' | '-publishedAt' | '-views' | '-likes' | '-comments' | '-trending' | '-hot' | '-best';
        /**
         * whether to include nsfw videos, if any
         */
        nsfw?: 'true' | 'false';
        nsfwFlagsIncluded?: NsfwFlag;
        nsfwFlagsExcluded?: NsfwFlag;
        /**
         * whether or not the video is a live
         */
        isLive?: boolean;
        /**
         * whether or not include live that are scheduled for later
         */
        includeScheduledLive?: boolean;
        /**
         * category id of the video (see [/videos/categories](#operation/getCategories))
         */
        categoryOneOf?: VideoCategorySet | Array<VideoCategorySet>;
        /**
         * licence id of the video (see [/videos/licences](#operation/getLicences))
         */
        licenceOneOf?: VideoLicenceSet | Array<VideoLicenceSet>;
        /**
         * language id of the video (see [/videos/languages](#operation/getLanguages)). Use `_unknown` to filter on videos that don't have a video language
         */
        languageOneOf?: VideoLanguageSet | Array<VideoLanguageSet>;
        /**
         * tag(s) of the video
         */
        tagsOneOf?: string | Array<string>;
        /**
         * tag(s) of the video, where all should be present in the video
         */
        tagsAllOf?: string | Array<string>;
        /**
         * **PeerTube >= 4.0** Display only local or remote objects
         */
        isLocal?: boolean;
        /**
         * **Only administrators and moderators can use this parameter**
         *
         * Include additional videos in results (can be combined using bitwise or operator)
         * - `0` NONE
         * - `1` NOT_PUBLISHED_STATE
         * - `2` BLACKLISTED
         * - `4` BLOCKED_OWNER
         * - `8` FILES
         * - `16` CAPTIONS
         * - `32` VIDEO SOURCE
         *
         */
        include?: 0 | 1 | 2 | 4 | 8 | 16 | 32;
        /**
         * **PeerTube >= 4.0** Display only videos that have HLS files
         */
        hasHLSFiles?: boolean;
        /**
         * **PeerTube >= 6.0** Display only videos that have Web Video files
         */
        hasWebVideoFiles?: boolean;
        /**
         * Find elements owned by this host
         */
        host?: string;
        /**
         * **PeerTube >= 6.2** **Admins and moderators only** filter on videos that contain one of these automatic tags
         */
        autoTagOneOf?: string | Array<string>;
        /**
         * **PeerTube >= 4.0** Display only videos in this specific privacy/privacies
         */
        privacyOneOf?: VideoPrivacySet;
        /**
         * Whether or not to exclude videos that are in the user's video history
         */
        excludeAlreadyWatched?: boolean;
        /**
         * Plain text search, applied to various parts of the model depending on endpoint
         */
        search?: string;
    };
    url: '/api/v1/accounts/{name}/videos';
};

export type GetAccountVideosResponses = {
    /**
     * successful operation
     */
    200: VideoListResponse;
};

export type GetAccountVideosResponse = GetAccountVideosResponses[keyof GetAccountVideosResponses];

export type GetAccountFollowersData = {
    body?: never;
    path: {
        /**
         * The username or handle of the account
         */
        name: string;
    };
    query?: {
        /**
         * Offset used to paginate results
         */
        start?: number;
        /**
         * Number of items to return
         */
        count?: number;
        /**
         * Sort followers by criteria
         */
        sort?: 'createdAt';
        /**
         * Plain text search, applied to various parts of the model depending on endpoint
         */
        search?: string;
    };
    url: '/api/v1/accounts/{name}/followers';
};

export type GetAccountFollowersResponses = {
    /**
     * successful operation
     */
    200: {
        total?: number;
        data?: Array<Follow>;
    };
};

export type GetAccountFollowersResponse = GetAccountFollowersResponses[keyof GetAccountFollowersResponses];

export type GetAccountsData = {
    body?: never;
    path?: never;
    query?: {
        /**
         * Offset used to paginate results
         */
        start?: number;
        /**
         * Number of items to return
         */
        count?: number;
        /**
         * Sort column
         */
        sort?: string;
    };
    url: '/api/v1/accounts';
};

export type GetAccountsResponses = {
    /**
     * successful operation
     */
    200: {
        total?: number;
        data?: Array<Account>;
    };
};

export type GetAccountsResponse = GetAccountsResponses[keyof GetAccountsResponses];

export type GetConfigData = {
    body?: never;
    path?: never;
    query?: never;
    url: '/api/v1/config';
};

export type GetConfigResponses = {
    /**
     * successful operation
     */
    200: ServerConfig;
};

export type GetConfigResponse = GetConfigResponses[keyof GetConfigResponses];

export type GetAboutData = {
    body?: never;
    path?: never;
    query?: never;
    url: '/api/v1/config/about';
};

export type GetAboutResponses = {
    /**
     * successful operation
     */
    200: ServerConfigAbout;
};

export type GetAboutResponse = GetAboutResponses[keyof GetAboutResponses];

export type DelCustomConfigData = {
    body?: never;
    path?: never;
    query?: never;
    url: '/api/v1/config/custom';
};

export type DelCustomConfigResponses = {
    /**
     * successful operation
     */
    200: unknown;
};

export type GetCustomConfigData = {
    body?: never;
    path?: never;
    query?: never;
    url: '/api/v1/config/custom';
};

export type GetCustomConfigResponses = {
    /**
     * successful operation
     */
    200: ServerConfigCustom;
};

export type GetCustomConfigResponse = GetCustomConfigResponses[keyof GetCustomConfigResponses];

export type PutCustomConfigData = {
    body?: never;
    path?: never;
    query?: never;
    url: '/api/v1/config/custom';
};

export type PutCustomConfigErrors = {
    /**
     * Arises when:
     * - the emailer is disabled and the instance is open to registrations
     * - web videos and hls are disabled with transcoding enabled - you need at least one enabled
     *
     */
    400: unknown;
};

export type PutCustomConfigResponses = {
    /**
     * successful operation
     */
    200: unknown;
};

export type PostApiV1ConfigInstanceBannerPickData = {
    body?: {
        /**
         * The file to upload.
         */
        bannerfile?: Blob | File;
    };
    path?: never;
    query?: never;
    url: '/api/v1/config/instance-banner/pick';
};

export type PostApiV1ConfigInstanceBannerPickErrors = {
    /**
     * image file too large
     */
    413: unknown;
};

export type PostApiV1ConfigInstanceBannerPickResponses = {
    /**
     * successful operation
     */
    204: void;
};

export type PostApiV1ConfigInstanceBannerPickResponse = PostApiV1ConfigInstanceBannerPickResponses[keyof PostApiV1ConfigInstanceBannerPickResponses];

export type DeleteApiV1ConfigInstanceBannerData = {
    body?: never;
    path?: never;
    query?: never;
    url: '/api/v1/config/instance-banner';
};

export type DeleteApiV1ConfigInstanceBannerResponses = {
    /**
     * successful operation
     */
    204: void;
};

export type DeleteApiV1ConfigInstanceBannerResponse = DeleteApiV1ConfigInstanceBannerResponses[keyof DeleteApiV1ConfigInstanceBannerResponses];

export type PostApiV1ConfigInstanceAvatarPickData = {
    body?: {
        /**
         * The file to upload.
         */
        avatarfile?: Blob | File;
    };
    path?: never;
    query?: never;
    url: '/api/v1/config/instance-avatar/pick';
};

export type PostApiV1ConfigInstanceAvatarPickErrors = {
    /**
     * image file too large
     */
    413: unknown;
};

export type PostApiV1ConfigInstanceAvatarPickResponses = {
    /**
     * successful operation
     */
    204: void;
};

export type PostApiV1ConfigInstanceAvatarPickResponse = PostApiV1ConfigInstanceAvatarPickResponses[keyof PostApiV1ConfigInstanceAvatarPickResponses];

export type DeleteApiV1ConfigInstanceAvatarData = {
    body?: never;
    path?: never;
    query?: never;
    url: '/api/v1/config/instance-avatar';
};

export type DeleteApiV1ConfigInstanceAvatarResponses = {
    /**
     * successful operation
     */
    204: void;
};

export type DeleteApiV1ConfigInstanceAvatarResponse = DeleteApiV1ConfigInstanceAvatarResponses[keyof DeleteApiV1ConfigInstanceAvatarResponses];

export type PostApiV1ConfigInstanceLogoLogoTypePickData = {
    body?: {
        /**
         * The file to upload.
         */
        logofile?: Blob | File;
    };
    path: {
        logoType: 'favicon' | 'header-wide' | 'header-square' | 'opengraph';
    };
    query?: never;
    url: '/api/v1/config/instance-logo/:logoType/pick';
};

export type PostApiV1ConfigInstanceLogoLogoTypePickErrors = {
    /**
     * image file too large
     */
    413: unknown;
};

export type PostApiV1ConfigInstanceLogoLogoTypePickResponses = {
    /**
     * successful operation
     */
    204: void;
};

export type PostApiV1ConfigInstanceLogoLogoTypePickResponse = PostApiV1ConfigInstanceLogoLogoTypePickResponses[keyof PostApiV1ConfigInstanceLogoLogoTypePickResponses];

export type DeleteApiV1ConfigInstanceLogoLogoTypeData = {
    body?: never;
    path: {
        logoType: 'favicon' | 'header-wide' | 'header-square' | 'opengraph';
    };
    query?: never;
    url: '/api/v1/config/instance-logo/:logoType';
};

export type DeleteApiV1ConfigInstanceLogoLogoTypeResponses = {
    /**
     * successful operation
     */
    204: void;
};

export type DeleteApiV1ConfigInstanceLogoLogoTypeResponse = DeleteApiV1ConfigInstanceLogoLogoTypeResponses[keyof DeleteApiV1ConfigInstanceLogoLogoTypeResponses];

export type GetApiV1CustomPagesHomepageInstanceData = {
    body?: never;
    path?: never;
    query?: never;
    url: '/api/v1/custom-pages/homepage/instance';
};

export type GetApiV1CustomPagesHomepageInstanceErrors = {
    /**
     * No homepage set
     */
    404: unknown;
};

export type GetApiV1CustomPagesHomepageInstanceResponses = {
    /**
     * successful operation
     */
    200: CustomHomepage;
};

export type GetApiV1CustomPagesHomepageInstanceResponse = GetApiV1CustomPagesHomepageInstanceResponses[keyof GetApiV1CustomPagesHomepageInstanceResponses];

export type PutApiV1CustomPagesHomepageInstanceData = {
    body?: {
        /**
         * content of the homepage, that will be injected in the client
         */
        content?: string;
    };
    path?: never;
    query?: never;
    url: '/api/v1/custom-pages/homepage/instance';
};

export type PutApiV1CustomPagesHomepageInstanceResponses = {
    /**
     * successful operation
     */
    204: void;
};

export type PutApiV1CustomPagesHomepageInstanceResponse = PutApiV1CustomPagesHomepageInstanceResponses[keyof PutApiV1CustomPagesHomepageInstanceResponses];

export type PostApiV1JobsPauseData = {
    body?: never;
    path?: never;
    query?: never;
    url: '/api/v1/jobs/pause';
};

export type PostApiV1JobsPauseResponses = {
    /**
     * successful operation
     */
    204: void;
};

export type PostApiV1JobsPauseResponse = PostApiV1JobsPauseResponses[keyof PostApiV1JobsPauseResponses];

export type PostApiV1JobsResumeData = {
    body?: never;
    path?: never;
    query?: never;
    url: '/api/v1/jobs/resume';
};

export type PostApiV1JobsResumeResponses = {
    /**
     * successful operation
     */
    204: void;
};

export type PostApiV1JobsResumeResponse = PostApiV1JobsResumeResponses[keyof PostApiV1JobsResumeResponses];

export type GetJobsData = {
    body?: never;
    path: {
        /**
         * The state of the job ('' for for no filter)
         */
        state: '' | 'active' | 'completed' | 'failed' | 'waiting' | 'delayed';
    };
    query?: {
        /**
         * job type
         */
        jobType?: 'activitypub-follow' | 'activitypub-http-broadcast' | 'activitypub-http-fetcher' | 'activitypub-http-unicast' | 'email' | 'video-transcoding' | 'video-file-import' | 'video-import' | 'videos-views-stats' | 'activitypub-refresher' | 'video-redundancy' | 'video-live-ending' | 'video-channel-import';
        /**
         * Offset used to paginate results
         */
        start?: number;
        /**
         * Number of items to return
         */
        count?: number;
        /**
         * Sort column
         */
        sort?: string;
    };
    url: '/api/v1/jobs/{state}';
};

export type GetJobsResponses = {
    /**
     * successful operation
     */
    200: {
        total?: number;
        data?: Array<Job>;
    };
};

export type GetJobsResponse = GetJobsResponses[keyof GetJobsResponses];

export type GetApiV1ServerFollowersData = {
    body?: never;
    path?: never;
    query?: {
        state?: 'pending' | 'accepted';
        actorType?: 'Person' | 'Application' | 'Group' | 'Service' | 'Organization';
        /**
         * Offset used to paginate results
         */
        start?: number;
        /**
         * Number of items to return
         */
        count?: number;
        /**
         * Sort column
         */
        sort?: string;
    };
    url: '/api/v1/server/followers';
};

export type GetApiV1ServerFollowersResponses = {
    /**
     * successful operation
     */
    200: {
        total?: number;
        data?: Array<Follow>;
    };
};

export type GetApiV1ServerFollowersResponse = GetApiV1ServerFollowersResponses[keyof GetApiV1ServerFollowersResponses];

export type DeleteApiV1ServerFollowersByHandleData = {
    body?: never;
    path: {
        /**
         * The remote actor handle to remove from your followers
         */
        handle: string;
    };
    query?: never;
    url: '/api/v1/server/followers/{handle}';
};

export type DeleteApiV1ServerFollowersByHandleErrors = {
    /**
     * follower not found
     */
    404: unknown;
};

export type DeleteApiV1ServerFollowersByHandleResponses = {
    /**
     * successful operation
     */
    204: void;
};

export type DeleteApiV1ServerFollowersByHandleResponse = DeleteApiV1ServerFollowersByHandleResponses[keyof DeleteApiV1ServerFollowersByHandleResponses];

export type PostApiV1ServerFollowersByHandleRejectData = {
    body?: never;
    path: {
        /**
         * The remote actor handle to remove from your followers
         */
        handle: string;
    };
    query?: never;
    url: '/api/v1/server/followers/{handle}/reject';
};

export type PostApiV1ServerFollowersByHandleRejectErrors = {
    /**
     * follower not found
     */
    404: unknown;
};

export type PostApiV1ServerFollowersByHandleRejectResponses = {
    /**
     * successful operation
     */
    204: void;
};

export type PostApiV1ServerFollowersByHandleRejectResponse = PostApiV1ServerFollowersByHandleRejectResponses[keyof PostApiV1ServerFollowersByHandleRejectResponses];

export type PostApiV1ServerFollowersByHandleAcceptData = {
    body?: never;
    path: {
        /**
         * The remote actor handle to remove from your followers
         */
        handle: string;
    };
    query?: never;
    url: '/api/v1/server/followers/{handle}/accept';
};

export type PostApiV1ServerFollowersByHandleAcceptErrors = {
    /**
     * follower not found
     */
    404: unknown;
};

export type PostApiV1ServerFollowersByHandleAcceptResponses = {
    /**
     * successful operation
     */
    204: void;
};

export type PostApiV1ServerFollowersByHandleAcceptResponse = PostApiV1ServerFollowersByHandleAcceptResponses[keyof PostApiV1ServerFollowersByHandleAcceptResponses];

export type GetApiV1ServerFollowingData = {
    body?: never;
    path?: never;
    query?: {
        state?: 'pending' | 'accepted';
        actorType?: 'Person' | 'Application' | 'Group' | 'Service' | 'Organization';
        /**
         * Offset used to paginate results
         */
        start?: number;
        /**
         * Number of items to return
         */
        count?: number;
        /**
         * Sort column
         */
        sort?: string;
    };
    url: '/api/v1/server/following';
};

export type GetApiV1ServerFollowingResponses = {
    /**
     * successful operation
     */
    200: {
        total?: number;
        data?: Array<Follow>;
    };
};

export type GetApiV1ServerFollowingResponse = GetApiV1ServerFollowingResponses[keyof GetApiV1ServerFollowingResponses];

export type PostApiV1ServerFollowingData = {
    body?: {
        hosts?: Array<string>;
        handles?: Array<string>;
    };
    path?: never;
    query?: never;
    url: '/api/v1/server/following';
};

export type PostApiV1ServerFollowingErrors = {
    /**
     * cannot follow a non-HTTPS server
     */
    500: unknown;
};

export type PostApiV1ServerFollowingResponses = {
    /**
     * successful operation
     */
    204: void;
};

export type PostApiV1ServerFollowingResponse = PostApiV1ServerFollowingResponses[keyof PostApiV1ServerFollowingResponses];

export type DeleteApiV1ServerFollowingByHostOrHandleData = {
    body?: never;
    path: {
        /**
         * The hostOrHandle to unfollow
         */
        hostOrHandle: string;
    };
    query?: never;
    url: '/api/v1/server/following/{hostOrHandle}';
};

export type DeleteApiV1ServerFollowingByHostOrHandleErrors = {
    /**
     * host or handle not found
     */
    404: unknown;
};

export type DeleteApiV1ServerFollowingByHostOrHandleResponses = {
    /**
     * successful operation
     */
    204: void;
};

export type DeleteApiV1ServerFollowingByHostOrHandleResponse = DeleteApiV1ServerFollowingByHostOrHandleResponses[keyof DeleteApiV1ServerFollowingByHostOrHandleResponses];

export type GetUsersData = {
    body?: never;
    path?: never;
    query?: {
        /**
         * Plain text search that will match with user usernames or emails
         */
        search?: string;
        /**
         * Filter results down to (un)banned users
         */
        blocked?: boolean;
        /**
         * Offset used to paginate results
         */
        start?: number;
        /**
         * Number of items to return
         */
        count?: number;
        /**
         * Sort users by criteria
         */
        sort?: '-id' | '-username' | '-createdAt';
    };
    url: '/api/v1/users';
};

export type GetUsersResponses = {
    /**
     * successful operation
     */
    200: Array<User>;
};

export type GetUsersResponse = GetUsersResponses[keyof GetUsersResponses];

export type AddUserData = {
    /**
     * If the smtp server is configured, you can leave the password empty and an email will be sent
     * asking the user to set it first.
     *
     */
    body: AddUser;
    path?: never;
    query?: never;
    url: '/api/v1/users';
};

export type AddUserErrors = {
    /**
     * insufficient authority to create an admin or moderator
     */
    403: unknown;
};

export type AddUserResponses = {
    /**
     * user created
     */
    200: AddUserResponse;
};

export type AddUserResponse2 = AddUserResponses[keyof AddUserResponses];

export type DelUserData = {
    body?: never;
    path: {
        /**
         * Entity id
         */
        id: Id;
    };
    query?: never;
    url: '/api/v1/users/{id}';
};

export type DelUserResponses = {
    /**
     * successful operation
     */
    204: void;
};

export type DelUserResponse = DelUserResponses[keyof DelUserResponses];

export type GetUserData = {
    body?: never;
    path: {
        /**
         * Entity id
         */
        id: Id;
    };
    query?: {
        /**
         * include statistics about the user (only available as a moderator/admin)
         */
        withStats?: boolean;
    };
    url: '/api/v1/users/{id}';
};

export type GetUserResponses = {
    /**
     * As an admin/moderator, you can request a response augmented with statistics about the user's
     * moderation relations and videos usage, by using the `withStats` parameter.
     *
     */
    200: User | UserWithStats;
};

export type GetUserResponse = GetUserResponses[keyof GetUserResponses];

export type PutUserData = {
    body: UpdateUser;
    path: {
        /**
         * Entity id
         */
        id: Id;
    };
    query?: never;
    url: '/api/v1/users/{id}';
};

export type PutUserResponses = {
    /**
     * successful operation
     */
    204: void;
};

export type PutUserResponse = PutUserResponses[keyof PutUserResponses];

export type GetOAuthClientData = {
    body?: never;
    path?: never;
    query?: never;
    url: '/api/v1/oauth-clients/local';
};

export type GetOAuthClientResponses = {
    /**
     * successful operation
     */
    200: OAuthClient;
};

export type GetOAuthClientResponse = GetOAuthClientResponses[keyof GetOAuthClientResponses];

export type GetOAuthTokenData = {
    body?: ({
        grant_type: 'password';
    } & OAuthTokenPassword) | ({
        grant_type: 'refresh_token';
    } & OAuthTokenRefreshToken);
    headers?: {
        /**
         * If the user enabled two factor authentication, you need to provide the OTP code in this header
         */
        'x-peertube-otp'?: string;
    };
    path?: never;
    query?: never;
    url: '/api/v1/users/token';
};

export type GetOAuthTokenErrors = {
    /**
     * Disambiguate via `code`:
     * - `invalid_client` for an unmatched `client_id`
     * - `invalid_grant` for unmatched credentials
     *
     */
    400: unknown;
    /**
     * Disambiguate via `code`:
     * - default value for a regular authentication failure
     * - `invalid_token` for an expired token
     * - `missing_two_factor` if two factor header is missing
     *
     */
    401: unknown;
};

export type GetOAuthTokenResponses = {
    /**
     * successful operation
     */
    200: {
        token_type?: string;
        /**
         * valid for 1 day
         */
        access_token?: string;
        /**
         * valid for 2 weeks
         */
        refresh_token?: string;
        expires_in?: number;
        refresh_token_expires_in?: number;
    };
};

export type GetOAuthTokenResponse = GetOAuthTokenResponses[keyof GetOAuthTokenResponses];

export type RevokeOAuthTokenData = {
    body?: never;
    path?: never;
    query?: never;
    url: '/api/v1/users/revoke-token';
};

export type RevokeOAuthTokenResponses = {
    /**
     * successful operation
     */
    200: unknown;
};

export type GetApiV1UsersByIdTokenSessionsData = {
    body?: never;
    path: {
        /**
         * Entity id
         */
        id: Id;
    };
    query?: never;
    url: '/api/v1/users/{id}/token-sessions';
};

export type GetApiV1UsersByIdTokenSessionsResponses = {
    /**
     * successful operation
     */
    200: {
        total?: number;
        data?: Array<TokenSession>;
    };
};

export type GetApiV1UsersByIdTokenSessionsResponse = GetApiV1UsersByIdTokenSessionsResponses[keyof GetApiV1UsersByIdTokenSessionsResponses];

export type GetApiV1UsersByIdTokenSessionsByTokenSessionIdRevokeData = {
    body?: never;
    path: {
        /**
         * Entity id
         */
        id: Id;
        /**
         * Token session Id
         */
        tokenSessionId: Id;
    };
    query?: never;
    url: '/api/v1/users/{id}/token-sessions/{tokenSessionId}/revoke';
};

export type GetApiV1UsersByIdTokenSessionsByTokenSessionIdRevokeResponses = {
    /**
     * successful operation
     */
    200: unknown;
};

export type ResendEmailToVerifyUserData = {
    body?: {
        /**
         * User email
         */
        email: string;
    };
    path?: never;
    query?: never;
    url: '/api/v1/users/ask-send-verify-email';
};

export type ResendEmailToVerifyUserResponses = {
    /**
     * successful operation
     */
    204: void;
};

export type ResendEmailToVerifyUserResponse = ResendEmailToVerifyUserResponses[keyof ResendEmailToVerifyUserResponses];

export type ResendEmailToVerifyRegistrationData = {
    body?: {
        /**
         * Registration email
         */
        email: string;
    };
    path?: never;
    query?: never;
    url: '/api/v1/users/registrations/ask-send-verify-email';
};

export type ResendEmailToVerifyRegistrationResponses = {
    /**
     * successful operation
     */
    204: void;
};

export type ResendEmailToVerifyRegistrationResponse = ResendEmailToVerifyRegistrationResponses[keyof ResendEmailToVerifyRegistrationResponses];

export type VerifyUserData = {
    body?: {
        verificationString: string;
        isPendingEmail?: boolean;
    };
    path: {
        /**
         * Entity id
         */
        id: Id;
    };
    query?: never;
    url: '/api/v1/users/{id}/verify-email';
};

export type VerifyUserErrors = {
    /**
     * invalid verification string
     */
    403: unknown;
    /**
     * user not found
     */
    404: unknown;
};

export type VerifyUserResponses = {
    /**
     * successful operation
     */
    204: void;
};

export type VerifyUserResponse = VerifyUserResponses[keyof VerifyUserResponses];

export type VerifyRegistrationEmailData = {
    body?: {
        verificationString: string;
    };
    path: {
        /**
         * Registration ID
         */
        registrationId: Id;
    };
    query?: never;
    url: '/api/v1/users/registrations/{registrationId}/verify-email';
};

export type VerifyRegistrationEmailErrors = {
    /**
     * invalid verification string
     */
    403: unknown;
    /**
     * registration not found
     */
    404: unknown;
};

export type VerifyRegistrationEmailResponses = {
    /**
     * successful operation
     */
    204: void;
};

export type VerifyRegistrationEmailResponse = VerifyRegistrationEmailResponses[keyof VerifyRegistrationEmailResponses];

export type PostApiV1UsersAskResetPasswordData = {
    body?: {
        /**
         * User email
         */
        email: string;
    };
    path?: never;
    query?: never;
    url: '/api/v1/users/ask-reset-password';
};

export type PostApiV1UsersAskResetPasswordResponses = {
    /**
     * successful operation
     */
    204: void;
};

export type PostApiV1UsersAskResetPasswordResponse = PostApiV1UsersAskResetPasswordResponses[keyof PostApiV1UsersAskResetPasswordResponses];

export type PostApiV1UsersByIdResetPasswordData = {
    body?: {
        verificationString: string;
        password: string;
    };
    path: {
        /**
         * Entity id
         */
        id: Id;
    };
    query?: never;
    url: '/api/v1/users/{id}/reset-password';
};

export type PostApiV1UsersByIdResetPasswordErrors = {
    /**
     * invalid verification string
     */
    403: unknown;
    /**
     * user not found
     */
    404: unknown;
};

export type PostApiV1UsersByIdResetPasswordResponses = {
    /**
     * successful operation
     */
    204: void;
};

export type PostApiV1UsersByIdResetPasswordResponse = PostApiV1UsersByIdResetPasswordResponses[keyof PostApiV1UsersByIdResetPasswordResponses];

export type RequestTwoFactorData = {
    body?: {
        /**
         * Password of the currently authenticated user
         */
        currentPassword?: string;
    };
    path: {
        /**
         * Entity id
         */
        id: Id;
    };
    query?: never;
    url: '/api/v1/users/{id}/two-factor/request';
};

export type RequestTwoFactorErrors = {
    /**
     * invalid password
     */
    403: unknown;
    /**
     * user not found
     */
    404: unknown;
};

export type RequestTwoFactorResponses = {
    /**
     * successful operation
     */
    200: Array<RequestTwoFactorResponse>;
};

export type RequestTwoFactorResponse2 = RequestTwoFactorResponses[keyof RequestTwoFactorResponses];

export type ConfirmTwoFactorRequestData = {
    body?: {
        /**
         * Token to identify the two factor request
         */
        requestToken: string;
        /**
         * OTP token generated by the app
         */
        otpToken: string;
    };
    path: {
        /**
         * Entity id
         */
        id: Id;
    };
    query?: never;
    url: '/api/v1/users/{id}/two-factor/confirm-request';
};

export type ConfirmTwoFactorRequestErrors = {
    /**
     * invalid request token or OTP token
     */
    403: unknown;
    /**
     * user not found
     */
    404: unknown;
};

export type ConfirmTwoFactorRequestResponses = {
    /**
     * successful operation
     */
    204: void;
};

export type ConfirmTwoFactorRequestResponse = ConfirmTwoFactorRequestResponses[keyof ConfirmTwoFactorRequestResponses];

export type DisableTwoFactorData = {
    body?: {
        /**
         * Password of the currently authenticated user
         */
        currentPassword?: string;
    };
    path: {
        /**
         * Entity id
         */
        id: Id;
    };
    query?: never;
    url: '/api/v1/users/{id}/two-factor/disable';
};

export type DisableTwoFactorErrors = {
    /**
     * invalid password
     */
    403: unknown;
    /**
     * user not found
     */
    404: unknown;
};

export type DisableTwoFactorResponses = {
    /**
     * successful operation
     */
    204: void;
};

export type DisableTwoFactorResponse = DisableTwoFactorResponses[keyof DisableTwoFactorResponses];

export type UserImportResumableCancelData = {
    body?: never;
    headers: {
        'Content-Length': number;
    };
    path: {
        /**
         * User id
         */
        userId: Id;
    };
    query: {
        /**
         * Created session id to proceed with. If you didn't send chunks in the last hour, it is
         * not valid anymore and you need to initialize a new upload.
         *
         */
        upload_id: string;
    };
    url: '/api/v1/users/{userId}/imports/import-resumable';
};

export type UserImportResumableCancelResponses = {
    /**
     * import cancelled
     */
    204: void;
};

export type UserImportResumableCancelResponse = UserImportResumableCancelResponses[keyof UserImportResumableCancelResponses];

export type UserImportResumableInitData = {
    body?: UserImportResumable;
    headers: {
        /**
         * Number of bytes that will be uploaded in subsequent requests. Set this value to the size of the file you are uploading.
         */
        'X-Upload-Content-Length': number;
        /**
         * MIME type of the file that you are uploading. Depending on your instance settings, acceptable values might vary.
         */
        'X-Upload-Content-Type': string;
    };
    path: {
        /**
         * User id
         */
        userId: Id;
    };
    query?: never;
    url: '/api/v1/users/{userId}/imports/import-resumable';
};

export type UserImportResumableInitResponses = {
    /**
     * created
     */
    201: unknown;
};

export type UserImportResumableData = {
    body?: Blob | File;
    headers: {
        /**
         * Specifies the bytes in the file that the request is uploading.
         *
         * For example, a value of `bytes 0-262143/1000000` shows that the request is sending the first
         * 262144 bytes (256 x 1024) in a 2,469,036 byte file.
         *
         */
        'Content-Range': string;
        /**
         * Size of the chunk that the request is sending.
         *
         * Remember that larger chunks are more efficient. PeerTube's web client uses chunks varying from
         * 1048576 bytes (~1MB) and increases or reduces size depending on connection health.
         *
         */
        'Content-Length': number;
    };
    path: {
        /**
         * User id
         */
        userId: Id;
    };
    query: {
        /**
         * Created session id to proceed with. If you didn't send chunks in the last hour, it is
         * not valid anymore and you need to initialize a new upload.
         *
         */
        upload_id: string;
    };
    url: '/api/v1/users/{userId}/imports/import-resumable';
};

export type UserImportResumableResponses = {
    /**
     * last chunk received: successful operation
     */
    204: void;
};

export type UserImportResumableResponse = UserImportResumableResponses[keyof UserImportResumableResponses];

export type GetLatestUserImportData = {
    body?: never;
    path: {
        /**
         * User id
         */
        userId: Id;
    };
    query?: never;
    url: '/api/v1/users/{userId}/imports/latest';
};

export type GetLatestUserImportResponses = {
    /**
     * successful operation
     */
    200: {
        id?: number;
        state?: {
            id?: UserImportState;
            label?: string;
        };
        createdAt?: string;
    };
};

export type GetLatestUserImportResponse = GetLatestUserImportResponses[keyof GetLatestUserImportResponses];

export type RequestUserExportData = {
    body?: {
        /**
         * Whether to include video files in the archive
         */
        withVideoFiles?: boolean;
    };
    path: {
        /**
         * User id
         */
        userId: Id;
    };
    query?: never;
    url: '/api/v1/users/{userId}/exports/request';
};

export type RequestUserExportResponses = {
    /**
     * successful operation
     */
    200: {
        export?: {
            id?: number;
        };
    };
};

export type RequestUserExportResponse = RequestUserExportResponses[keyof RequestUserExportResponses];

export type ListUserExportsData = {
    body?: never;
    path: {
        /**
         * User id
         */
        userId: Id;
    };
    query?: never;
    url: '/api/v1/users/{userId}/exports';
};

export type ListUserExportsResponses = {
    /**
     * successful operation
     */
    200: {
        id?: number;
        state?: {
            id?: UserExportState;
            label?: string;
        };
        /**
         * Size of the archive file in bytes
         */
        size?: number;
        /**
         * This URL already contains the JWT token, so no additional authentication credentials are required
         */
        privateDownloadUrl?: string;
        createdAt?: string;
        expiresOn?: string;
    };
};

export type ListUserExportsResponse = ListUserExportsResponses[keyof ListUserExportsResponses];

export type DeleteUserExportData = {
    body?: never;
    path: {
        /**
         * User id
         */
        userId: Id;
        /**
         * Entity id
         */
        id: Id;
    };
    query?: never;
    url: '/api/v1/users/{userId}/exports/{id}';
};

export type DeleteUserExportResponses = {
    /**
     * successful operation
     */
    204: void;
};

export type DeleteUserExportResponse = DeleteUserExportResponses[keyof DeleteUserExportResponses];

export type GetUserInfoData = {
    body?: never;
    path?: never;
    query?: never;
    url: '/api/v1/users/me';
};

export type GetUserInfoResponses = {
    /**
     * successful operation
     */
    200: Array<User>;
};

export type GetUserInfoResponse = GetUserInfoResponses[keyof GetUserInfoResponses];

export type PutUserInfoData = {
    body: UpdateMe;
    path?: never;
    query?: never;
    url: '/api/v1/users/me';
};

export type PutUserInfoResponses = {
    /**
     * successful operation
     */
    204: void;
};

export type PutUserInfoResponse = PutUserInfoResponses[keyof PutUserInfoResponses];

export type GetApiV1UsersMeVideosCommentsData = {
    body?: never;
    path?: never;
    query?: {
        /**
         * Plain text search, applied to various parts of the model depending on endpoint
         */
        search?: string;
        /**
         * Filter comments by searching on the account
         */
        searchAccount?: string;
        /**
         * Filter comments by searching on the video
         */
        searchVideo?: string;
        /**
         * Limit results on this specific video
         */
        videoId?: number;
        /**
         * Limit results on this specific video channel
         */
        videoChannelId?: number;
        /**
         * **PeerTube >= 6.2** filter on comments that contain one of these automatic tags
         */
        autoTagOneOf?: string | Array<string>;
        /**
         * only display comments that are held for review
         */
        isHeldForReview?: boolean;
    };
    url: '/api/v1/users/me/videos/comments';
};

export type GetApiV1UsersMeVideosCommentsResponses = {
    /**
     * successful operation
     */
    200: {
        total?: number;
        data?: Array<VideoCommentForOwnerOrAdmin>;
    };
};

export type GetApiV1UsersMeVideosCommentsResponse = GetApiV1UsersMeVideosCommentsResponses[keyof GetApiV1UsersMeVideosCommentsResponses];

export type GetApiV1UsersMeVideosImportsData = {
    body?: never;
    path?: never;
    query?: {
        /**
         * Offset used to paginate results
         */
        start?: number;
        /**
         * Number of items to return
         */
        count?: number;
        /**
         * Sort column
         */
        sort?: string;
        /**
         * Filter on import target URL
         */
        targetUrl?: string;
        /**
         * Filter on imports created by a specific channel synchronization
         */
        videoChannelSyncId?: number;
        /**
         * Search in video names
         */
        search?: string;
    };
    url: '/api/v1/users/me/videos/imports';
};

export type GetApiV1UsersMeVideosImportsResponses = {
    /**
     * successful operation
     */
    200: VideoImportsList;
};

export type GetApiV1UsersMeVideosImportsResponse = GetApiV1UsersMeVideosImportsResponses[keyof GetApiV1UsersMeVideosImportsResponses];

export type GetApiV1UsersMeVideoQuotaUsedData = {
    body?: never;
    path?: never;
    query?: never;
    url: '/api/v1/users/me/video-quota-used';
};

export type GetApiV1UsersMeVideoQuotaUsedResponses = {
    /**
     * successful operation
     */
    200: {
        /**
         * The user video quota used so far in bytes
         */
        videoQuotaUsed?: number;
        /**
         * The user video quota used today in bytes
         */
        videoQuotaUsedDaily?: number;
    };
};

export type GetApiV1UsersMeVideoQuotaUsedResponse = GetApiV1UsersMeVideoQuotaUsedResponses[keyof GetApiV1UsersMeVideoQuotaUsedResponses];

export type GetApiV1UsersMeVideosByVideoIdRatingData = {
    body?: never;
    path: {
        /**
         * The video id
         */
        videoId: 8;
    };
    query?: never;
    url: '/api/v1/users/me/videos/{videoId}/rating';
};

export type GetApiV1UsersMeVideosByVideoIdRatingResponses = {
    /**
     * successful operation
     */
    200: GetMeVideoRating;
};

export type GetApiV1UsersMeVideosByVideoIdRatingResponse = GetApiV1UsersMeVideosByVideoIdRatingResponses[keyof GetApiV1UsersMeVideosByVideoIdRatingResponses];

export type GetApiV1UsersMeVideosData = {
    body?: never;
    path?: never;
    query?: {
        /**
         * **PeerTube >= 7.2** Filter on videos that are published by a channel with one of these names
         */
        channelNameOneOf?: string | Array<string>;
        /**
         * Offset used to paginate results
         */
        start?: number;
        /**
         * Number of items to return
         */
        count?: number;
        /**
         * if you don't need the `total` in the response
         */
        skipCount?: 'true' | 'false';
        /**
         * Sort videos by criteria (prefixing with `-` means `DESC` order):
         * * `hot` - Adaptation of Reddit "hot" algorithm taking into account video views, likes, dislikes and comments and publication date
         * * `best` - Same than `hot`, but also takes into account user video history
         * * `trending` - Sort videos by recent views ("recent" is defined by the admin)
         * * `views` - Sort videos using their `views` counter
         * * `publishedAt` - Sort by video publication date (when it became publicly available)
         *
         */
        sort?: 'name' | '-duration' | '-createdAt' | '-publishedAt' | '-views' | '-likes' | '-comments' | '-trending' | '-hot' | '-best';
        /**
         * whether to include nsfw videos, if any
         */
        nsfw?: 'true' | 'false';
        nsfwFlagsIncluded?: NsfwFlag;
        nsfwFlagsExcluded?: NsfwFlag;
        /**
         * whether or not the video is a live
         */
        isLive?: boolean;
        /**
         * whether or not include live that are scheduled for later
         */
        includeScheduledLive?: boolean;
        /**
         * category id of the video (see [/videos/categories](#operation/getCategories))
         */
        categoryOneOf?: VideoCategorySet | Array<VideoCategorySet>;
        /**
         * licence id of the video (see [/videos/licences](#operation/getLicences))
         */
        licenceOneOf?: VideoLicenceSet | Array<VideoLicenceSet>;
        /**
         * language id of the video (see [/videos/languages](#operation/getLanguages)). Use `_unknown` to filter on videos that don't have a video language
         */
        languageOneOf?: VideoLanguageSet | Array<VideoLanguageSet>;
        /**
         * tag(s) of the video
         */
        tagsOneOf?: string | Array<string>;
        /**
         * tag(s) of the video, where all should be present in the video
         */
        tagsAllOf?: string | Array<string>;
        /**
         * **PeerTube >= 4.0** Display only local or remote objects
         */
        isLocal?: boolean;
        /**
         * **Only administrators and moderators can use this parameter**
         *
         * Include additional videos in results (can be combined using bitwise or operator)
         * - `0` NONE
         * - `1` NOT_PUBLISHED_STATE
         * - `2` BLACKLISTED
         * - `4` BLOCKED_OWNER
         * - `8` FILES
         * - `16` CAPTIONS
         * - `32` VIDEO SOURCE
         *
         */
        include?: 0 | 1 | 2 | 4 | 8 | 16 | 32;
        /**
         * **PeerTube >= 4.0** Display only videos that have HLS files
         */
        hasHLSFiles?: boolean;
        /**
         * **PeerTube >= 6.0** Display only videos that have Web Video files
         */
        hasWebVideoFiles?: boolean;
        /**
         * Find elements owned by this host
         */
        host?: string;
        /**
         * **PeerTube >= 6.2** **Admins and moderators only** filter on videos that contain one of these automatic tags
         */
        autoTagOneOf?: string | Array<string>;
        /**
         * **PeerTube >= 4.0** Display only videos in this specific privacy/privacies
         */
        privacyOneOf?: VideoPrivacySet;
        /**
         * Whether or not to exclude videos that are in the user's video history
         */
        excludeAlreadyWatched?: boolean;
        /**
         * Plain text search, applied to various parts of the model depending on endpoint
         */
        search?: string;
    };
    url: '/api/v1/users/me/videos';
};

export type GetApiV1UsersMeVideosResponses = {
    /**
     * successful operation
     */
    200: VideoListResponse;
};

export type GetApiV1UsersMeVideosResponse = GetApiV1UsersMeVideosResponses[keyof GetApiV1UsersMeVideosResponses];

export type GetApiV1UsersMeSubscriptionsData = {
    body?: never;
    path?: never;
    query?: {
        /**
         * Offset used to paginate results
         */
        start?: number;
        /**
         * Number of items to return
         */
        count?: number;
        sort?: '-id' | '-createdAt' | '-channelUpdatedAt';
    };
    url: '/api/v1/users/me/subscriptions';
};

export type GetApiV1UsersMeSubscriptionsResponses = {
    /**
     * successful operation
     */
    200: VideoChannelList;
};

export type GetApiV1UsersMeSubscriptionsResponse = GetApiV1UsersMeSubscriptionsResponses[keyof GetApiV1UsersMeSubscriptionsResponses];

export type PostApiV1UsersMeSubscriptionsData = {
    body?: {
        /**
         * uri of the video channels to subscribe to
         */
        uri: string;
    };
    path?: never;
    query?: never;
    url: '/api/v1/users/me/subscriptions';
};

export type PostApiV1UsersMeSubscriptionsResponses = {
    /**
     * successful operation
     */
    204: void;
};

export type PostApiV1UsersMeSubscriptionsResponse = PostApiV1UsersMeSubscriptionsResponses[keyof PostApiV1UsersMeSubscriptionsResponses];

export type GetApiV1UsersMeSubscriptionsExistData = {
    body?: never;
    path?: never;
    query: {
        /**
         * list of uris to check if each is part of the user subscriptions
         */
        uris: Array<string>;
    };
    url: '/api/v1/users/me/subscriptions/exist';
};

export type GetApiV1UsersMeSubscriptionsExistResponses = {
    /**
     * successful operation
     */
    200: {
        [key: string]: unknown;
    };
};

export type GetApiV1UsersMeSubscriptionsExistResponse = GetApiV1UsersMeSubscriptionsExistResponses[keyof GetApiV1UsersMeSubscriptionsExistResponses];

export type GetApiV1UsersMeSubscriptionsVideosData = {
    body?: never;
    path?: never;
    query?: {
        /**
         * Offset used to paginate results
         */
        start?: number;
        /**
         * Number of items to return
         */
        count?: number;
        /**
         * if you don't need the `total` in the response
         */
        skipCount?: 'true' | 'false';
        /**
         * Sort videos by criteria (prefixing with `-` means `DESC` order):
         * * `hot` - Adaptation of Reddit "hot" algorithm taking into account video views, likes, dislikes and comments and publication date
         * * `best` - Same than `hot`, but also takes into account user video history
         * * `trending` - Sort videos by recent views ("recent" is defined by the admin)
         * * `views` - Sort videos using their `views` counter
         * * `publishedAt` - Sort by video publication date (when it became publicly available)
         *
         */
        sort?: 'name' | '-duration' | '-createdAt' | '-publishedAt' | '-views' | '-likes' | '-comments' | '-trending' | '-hot' | '-best';
        /**
         * whether to include nsfw videos, if any
         */
        nsfw?: 'true' | 'false';
        nsfwFlagsIncluded?: NsfwFlag;
        nsfwFlagsExcluded?: NsfwFlag;
        /**
         * whether or not the video is a live
         */
        isLive?: boolean;
        /**
         * whether or not include live that are scheduled for later
         */
        includeScheduledLive?: boolean;
        /**
         * category id of the video (see [/videos/categories](#operation/getCategories))
         */
        categoryOneOf?: VideoCategorySet | Array<VideoCategorySet>;
        /**
         * licence id of the video (see [/videos/licences](#operation/getLicences))
         */
        licenceOneOf?: VideoLicenceSet | Array<VideoLicenceSet>;
        /**
         * language id of the video (see [/videos/languages](#operation/getLanguages)). Use `_unknown` to filter on videos that don't have a video language
         */
        languageOneOf?: VideoLanguageSet | Array<VideoLanguageSet>;
        /**
         * tag(s) of the video
         */
        tagsOneOf?: string | Array<string>;
        /**
         * tag(s) of the video, where all should be present in the video
         */
        tagsAllOf?: string | Array<string>;
        /**
         * **PeerTube >= 4.0** Display only local or remote objects
         */
        isLocal?: boolean;
        /**
         * **Only administrators and moderators can use this parameter**
         *
         * Include additional videos in results (can be combined using bitwise or operator)
         * - `0` NONE
         * - `1` NOT_PUBLISHED_STATE
         * - `2` BLACKLISTED
         * - `4` BLOCKED_OWNER
         * - `8` FILES
         * - `16` CAPTIONS
         * - `32` VIDEO SOURCE
         *
         */
        include?: 0 | 1 | 2 | 4 | 8 | 16 | 32;
        /**
         * **PeerTube >= 4.0** Display only videos that have HLS files
         */
        hasHLSFiles?: boolean;
        /**
         * **PeerTube >= 6.0** Display only videos that have Web Video files
         */
        hasWebVideoFiles?: boolean;
        /**
         * Find elements owned by this host
         */
        host?: string;
        /**
         * **PeerTube >= 6.2** **Admins and moderators only** filter on videos that contain one of these automatic tags
         */
        autoTagOneOf?: string | Array<string>;
        /**
         * **PeerTube >= 4.0** Display only videos in this specific privacy/privacies
         */
        privacyOneOf?: VideoPrivacySet;
        /**
         * Whether or not to exclude videos that are in the user's video history
         */
        excludeAlreadyWatched?: boolean;
        /**
         * Plain text search, applied to various parts of the model depending on endpoint
         */
        search?: string;
    };
    url: '/api/v1/users/me/subscriptions/videos';
};

export type GetApiV1UsersMeSubscriptionsVideosResponses = {
    /**
     * successful operation
     */
    200: VideoListResponse;
};

export type GetApiV1UsersMeSubscriptionsVideosResponse = GetApiV1UsersMeSubscriptionsVideosResponses[keyof GetApiV1UsersMeSubscriptionsVideosResponses];

export type DeleteApiV1UsersMeSubscriptionsBySubscriptionHandleData = {
    body?: never;
    path: {
        /**
         * The subscription handle
         */
        subscriptionHandle: string;
    };
    query?: never;
    url: '/api/v1/users/me/subscriptions/{subscriptionHandle}';
};

export type DeleteApiV1UsersMeSubscriptionsBySubscriptionHandleResponses = {
    /**
     * successful operation
     */
    204: void;
};

export type DeleteApiV1UsersMeSubscriptionsBySubscriptionHandleResponse = DeleteApiV1UsersMeSubscriptionsBySubscriptionHandleResponses[keyof DeleteApiV1UsersMeSubscriptionsBySubscriptionHandleResponses];

export type GetApiV1UsersMeSubscriptionsBySubscriptionHandleData = {
    body?: never;
    path: {
        /**
         * The subscription handle
         */
        subscriptionHandle: string;
    };
    query?: never;
    url: '/api/v1/users/me/subscriptions/{subscriptionHandle}';
};

export type GetApiV1UsersMeSubscriptionsBySubscriptionHandleResponses = {
    /**
     * successful operation
     */
    200: VideoChannel;
};

export type GetApiV1UsersMeSubscriptionsBySubscriptionHandleResponse = GetApiV1UsersMeSubscriptionsBySubscriptionHandleResponses[keyof GetApiV1UsersMeSubscriptionsBySubscriptionHandleResponses];

export type GetApiV1UsersMeNotificationsData = {
    body?: never;
    path?: never;
    query?: {
        /**
         * only list notifications of these types
         */
        typeOneOf?: Array<NotificationType>;
        /**
         * only list unread notifications
         */
        unread?: boolean;
        /**
         * Offset used to paginate results
         */
        start?: number;
        /**
         * Number of items to return
         */
        count?: number;
        /**
         * Sort column
         */
        sort?: string;
    };
    url: '/api/v1/users/me/notifications';
};

export type GetApiV1UsersMeNotificationsResponses = {
    /**
     * successful operation
     */
    200: NotificationListResponse;
};

export type GetApiV1UsersMeNotificationsResponse = GetApiV1UsersMeNotificationsResponses[keyof GetApiV1UsersMeNotificationsResponses];

export type PostApiV1UsersMeNotificationsReadData = {
    body?: {
        /**
         * ids of the notifications to mark as read
         */
        ids: Array<number>;
    };
    path?: never;
    query?: never;
    url: '/api/v1/users/me/notifications/read';
};

export type PostApiV1UsersMeNotificationsReadResponses = {
    /**
     * successful operation
     */
    204: void;
};

export type PostApiV1UsersMeNotificationsReadResponse = PostApiV1UsersMeNotificationsReadResponses[keyof PostApiV1UsersMeNotificationsReadResponses];

export type PostApiV1UsersMeNotificationsReadAllData = {
    body?: never;
    path?: never;
    query?: never;
    url: '/api/v1/users/me/notifications/read-all';
};

export type PostApiV1UsersMeNotificationsReadAllResponses = {
    /**
     * successful operation
     */
    204: void;
};

export type PostApiV1UsersMeNotificationsReadAllResponse = PostApiV1UsersMeNotificationsReadAllResponses[keyof PostApiV1UsersMeNotificationsReadAllResponses];

export type PutApiV1UsersMeNotificationSettingsData = {
    body?: {
        abuseAsModerator?: NotificationSettingValue;
        videoAutoBlacklistAsModerator?: NotificationSettingValue;
        newUserRegistration?: NotificationSettingValue;
        newVideoFromSubscription?: NotificationSettingValue;
        blacklistOnMyVideo?: NotificationSettingValue;
        myVideoPublished?: NotificationSettingValue;
        myVideoImportFinished?: NotificationSettingValue;
        commentMention?: NotificationSettingValue;
        newCommentOnMyVideo?: NotificationSettingValue;
        newFollow?: NotificationSettingValue;
        newInstanceFollower?: NotificationSettingValue;
        autoInstanceFollowing?: NotificationSettingValue;
        abuseStateChange?: NotificationSettingValue;
        abuseNewMessage?: NotificationSettingValue;
        newPeerTubeVersion?: NotificationSettingValue;
        newPluginVersion?: NotificationSettingValue;
        myVideoStudioEditionFinished?: NotificationSettingValue;
        myVideoTranscriptionGenerated?: NotificationSettingValue;
    };
    path?: never;
    query?: never;
    url: '/api/v1/users/me/notification-settings';
};

export type PutApiV1UsersMeNotificationSettingsResponses = {
    /**
     * successful operation
     */
    204: void;
};

export type PutApiV1UsersMeNotificationSettingsResponse = PutApiV1UsersMeNotificationSettingsResponses[keyof PutApiV1UsersMeNotificationSettingsResponses];

export type GetApiV1UsersMeHistoryVideosData = {
    body?: never;
    path?: never;
    query?: {
        /**
         * Offset used to paginate results
         */
        start?: number;
        /**
         * Number of items to return
         */
        count?: number;
        /**
         * Plain text search, applied to various parts of the model depending on endpoint
         */
        search?: string;
    };
    url: '/api/v1/users/me/history/videos';
};

export type GetApiV1UsersMeHistoryVideosResponses = {
    /**
     * successful operation
     */
    200: VideoListResponse;
};

export type GetApiV1UsersMeHistoryVideosResponse = GetApiV1UsersMeHistoryVideosResponses[keyof GetApiV1UsersMeHistoryVideosResponses];

export type DeleteApiV1UsersMeHistoryVideosByVideoIdData = {
    body?: never;
    path: {
        videoId: 8;
    };
    query?: never;
    url: '/api/v1/users/me/history/videos/{videoId}';
};

export type DeleteApiV1UsersMeHistoryVideosByVideoIdResponses = {
    /**
     * successful operation
     */
    204: void;
};

export type DeleteApiV1UsersMeHistoryVideosByVideoIdResponse = DeleteApiV1UsersMeHistoryVideosByVideoIdResponses[keyof DeleteApiV1UsersMeHistoryVideosByVideoIdResponses];

export type PostApiV1UsersMeHistoryVideosRemoveData = {
    body?: {
        /**
         * history before this date will be deleted
         */
        beforeDate?: string;
    };
    path?: never;
    query?: never;
    url: '/api/v1/users/me/history/videos/remove';
};

export type PostApiV1UsersMeHistoryVideosRemoveResponses = {
    /**
     * successful operation
     */
    204: void;
};

export type PostApiV1UsersMeHistoryVideosRemoveResponse = PostApiV1UsersMeHistoryVideosRemoveResponses[keyof PostApiV1UsersMeHistoryVideosRemoveResponses];

export type PostApiV1UsersMeAvatarPickData = {
    body?: {
        /**
         * The file to upload
         */
        avatarfile?: Blob | File;
    };
    path?: never;
    query?: never;
    url: '/api/v1/users/me/avatar/pick';
};

export type PostApiV1UsersMeAvatarPickErrors = {
    /**
     * image file too large
     */
    413: unknown;
};

export type PostApiV1UsersMeAvatarPickResponses = {
    /**
     * successful operation
     */
    200: {
        avatars?: Array<ActorImage>;
    };
};

export type PostApiV1UsersMeAvatarPickResponse = PostApiV1UsersMeAvatarPickResponses[keyof PostApiV1UsersMeAvatarPickResponses];

export type DeleteApiV1UsersMeAvatarData = {
    body?: never;
    path?: never;
    query?: never;
    url: '/api/v1/users/me/avatar';
};

export type DeleteApiV1UsersMeAvatarResponses = {
    /**
     * successful operation
     */
    204: void;
};

export type DeleteApiV1UsersMeAvatarResponse = DeleteApiV1UsersMeAvatarResponses[keyof DeleteApiV1UsersMeAvatarResponses];

export type RegisterUserData = {
    body: RegisterUser;
    path?: never;
    query?: never;
    url: '/api/v1/users/register';
};

export type RegisterUserErrors = {
    /**
     * request error
     */
    400: unknown;
    /**
     * user registration is not enabled, user limit is reached, registration is not allowed for the ip, requires approval or blocked by a plugin
     */
    403: unknown;
    /**
     * a user with this username, channel name or email already exists
     */
    409: unknown;
};

export type RegisterUserResponses = {
    /**
     * successful operation
     */
    204: void;
};

export type RegisterUserResponse = RegisterUserResponses[keyof RegisterUserResponses];

export type RequestRegistrationData = {
    body?: UserRegistrationRequest;
    path?: never;
    query?: never;
    url: '/api/v1/users/registrations/request';
};

export type RequestRegistrationErrors = {
    /**
     * request error or signup approval is not enabled on the instance
     */
    400: unknown;
    /**
     * user registration is not enabled, user limit is reached, registration is not allowed for the ip or blocked by a plugin
     */
    403: unknown;
    /**
     * a user or registration with this username, channel name or email already exists
     */
    409: unknown;
};

export type RequestRegistrationResponses = {
    /**
     * successful operation
     */
    200: UserRegistration;
};

export type RequestRegistrationResponse = RequestRegistrationResponses[keyof RequestRegistrationResponses];

export type AcceptRegistrationData = {
    body?: UserRegistrationAcceptOrReject;
    path: {
        /**
         * Registration ID
         */
        registrationId: Id;
    };
    query?: never;
    url: '/api/v1/users/registrations/{registrationId}/accept';
};

export type AcceptRegistrationResponses = {
    /**
     * successful operation
     */
    204: void;
};

export type AcceptRegistrationResponse = AcceptRegistrationResponses[keyof AcceptRegistrationResponses];

export type RejectRegistrationData = {
    body?: UserRegistrationAcceptOrReject;
    path: {
        /**
         * Registration ID
         */
        registrationId: Id;
    };
    query?: never;
    url: '/api/v1/users/registrations/{registrationId}/reject';
};

export type RejectRegistrationResponses = {
    /**
     * successful operation
     */
    204: void;
};

export type RejectRegistrationResponse = RejectRegistrationResponses[keyof RejectRegistrationResponses];

export type DeleteRegistrationData = {
    body?: never;
    path: {
        /**
         * Registration ID
         */
        registrationId: Id;
    };
    query?: never;
    url: '/api/v1/users/registrations/{registrationId}';
};

export type DeleteRegistrationResponses = {
    /**
     * successful operation
     */
    204: void;
};

export type DeleteRegistrationResponse = DeleteRegistrationResponses[keyof DeleteRegistrationResponses];

export type ListRegistrationsData = {
    body?: never;
    path?: never;
    query?: {
        /**
         * Offset used to paginate results
         */
        start?: number;
        /**
         * Number of items to return
         */
        count?: number;
        search?: string;
        sort?: '-createdAt' | 'createdAt' | 'state' | '-state';
    };
    url: '/api/v1/users/registrations';
};

export type ListRegistrationsResponses = {
    /**
     * successful operation
     */
    200: {
        total?: number;
        data?: Array<UserRegistration>;
    };
};

export type ListRegistrationsResponse = ListRegistrationsResponses[keyof ListRegistrationsResponses];

export type GetApiV1VideosOwnershipData = {
    body?: never;
    path?: never;
    query?: never;
    url: '/api/v1/videos/ownership';
};

export type GetApiV1VideosOwnershipResponses = {
    /**
     * successful operation
     */
    200: unknown;
};

export type PostApiV1VideosOwnershipByIdAcceptData = {
    body?: never;
    path: {
        /**
         * The object id, uuid or short uuid
         */
        id: Id | UuiDv4 | ShortUuid;
    };
    query?: never;
    url: '/api/v1/videos/ownership/{id}/accept';
};

export type PostApiV1VideosOwnershipByIdAcceptErrors = {
    /**
     * cannot terminate an ownership change of another user
     */
    403: unknown;
    /**
     * video ownership change not found
     */
    404: unknown;
};

export type PostApiV1VideosOwnershipByIdAcceptResponses = {
    /**
     * successful operation
     */
    204: void;
};

export type PostApiV1VideosOwnershipByIdAcceptResponse = PostApiV1VideosOwnershipByIdAcceptResponses[keyof PostApiV1VideosOwnershipByIdAcceptResponses];

export type PostApiV1VideosOwnershipByIdRefuseData = {
    body?: never;
    path: {
        /**
         * The object id, uuid or short uuid
         */
        id: Id | UuiDv4 | ShortUuid;
    };
    query?: never;
    url: '/api/v1/videos/ownership/{id}/refuse';
};

export type PostApiV1VideosOwnershipByIdRefuseErrors = {
    /**
     * cannot terminate an ownership change of another user
     */
    403: unknown;
    /**
     * video ownership change not found
     */
    404: unknown;
};

export type PostApiV1VideosOwnershipByIdRefuseResponses = {
    /**
     * successful operation
     */
    204: void;
};

export type PostApiV1VideosOwnershipByIdRefuseResponse = PostApiV1VideosOwnershipByIdRefuseResponses[keyof PostApiV1VideosOwnershipByIdRefuseResponses];

export type PostApiV1VideosByIdGiveOwnershipData = {
    body: {
        username: string;
    };
    path: {
        /**
         * The object id, uuid or short uuid
         */
        id: Id | UuiDv4 | ShortUuid;
    };
    query?: never;
    url: '/api/v1/videos/{id}/give-ownership';
};

export type PostApiV1VideosByIdGiveOwnershipErrors = {
    /**
     * changing video ownership to a remote account is not supported yet
     */
    400: unknown;
    /**
     * video not found
     */
    404: unknown;
};

export type PostApiV1VideosByIdGiveOwnershipResponses = {
    /**
     * successful operation
     */
    204: void;
};

export type PostApiV1VideosByIdGiveOwnershipResponse = PostApiV1VideosByIdGiveOwnershipResponses[keyof PostApiV1VideosByIdGiveOwnershipResponses];

export type RequestVideoTokenData = {
    body?: never;
    headers?: {
        /**
         * Required on password protected video
         */
        'x-peertube-video-password'?: string;
    };
    path: {
        /**
         * The object id, uuid or short uuid
         */
        id: Id | UuiDv4 | ShortUuid;
    };
    query?: never;
    url: '/api/v1/videos/{id}/token';
};

export type RequestVideoTokenErrors = {
    /**
     * incorrect parameters
     */
    400: unknown;
    /**
     * video not found
     */
    404: unknown;
};

export type RequestVideoTokenResponses = {
    /**
     * successful operation
     */
    200: VideoTokenResponse;
};

export type RequestVideoTokenResponse = RequestVideoTokenResponses[keyof RequestVideoTokenResponses];

export type PostApiV1VideosByIdStudioEditData = {
    body: VideoStudioCreateTask;
    path: {
        /**
         * The object id, uuid or short uuid
         */
        id: Id | UuiDv4 | ShortUuid;
    };
    query?: never;
    url: '/api/v1/videos/{id}/studio/edit';
};

export type PostApiV1VideosByIdStudioEditErrors = {
    /**
     * incorrect parameters
     */
    400: unknown;
    /**
     * video not found
     */
    404: unknown;
};

export type PostApiV1VideosByIdStudioEditResponses = {
    /**
     * successful operation
     */
    204: void;
};

export type PostApiV1VideosByIdStudioEditResponse = PostApiV1VideosByIdStudioEditResponses[keyof PostApiV1VideosByIdStudioEditResponses];

export type GetVideosData = {
    body?: never;
    path?: never;
    query?: {
        /**
         * Offset used to paginate results
         */
        start?: number;
        /**
         * Number of items to return
         */
        count?: number;
        /**
         * if you don't need the `total` in the response
         */
        skipCount?: 'true' | 'false';
        /**
         * Sort videos by criteria (prefixing with `-` means `DESC` order):
         * * `hot` - Adaptation of Reddit "hot" algorithm taking into account video views, likes, dislikes and comments and publication date
         * * `best` - Same than `hot`, but also takes into account user video history
         * * `trending` - Sort videos by recent views ("recent" is defined by the admin)
         * * `views` - Sort videos using their `views` counter
         * * `publishedAt` - Sort by video publication date (when it became publicly available)
         *
         */
        sort?: 'name' | '-duration' | '-createdAt' | '-publishedAt' | '-views' | '-likes' | '-comments' | '-trending' | '-hot' | '-best';
        /**
         * whether to include nsfw videos, if any
         */
        nsfw?: 'true' | 'false';
        nsfwFlagsIncluded?: NsfwFlag;
        nsfwFlagsExcluded?: NsfwFlag;
        /**
         * whether or not the video is a live
         */
        isLive?: boolean;
        /**
         * whether or not include live that are scheduled for later
         */
        includeScheduledLive?: boolean;
        /**
         * category id of the video (see [/videos/categories](#operation/getCategories))
         */
        categoryOneOf?: VideoCategorySet | Array<VideoCategorySet>;
        /**
         * licence id of the video (see [/videos/licences](#operation/getLicences))
         */
        licenceOneOf?: VideoLicenceSet | Array<VideoLicenceSet>;
        /**
         * language id of the video (see [/videos/languages](#operation/getLanguages)). Use `_unknown` to filter on videos that don't have a video language
         */
        languageOneOf?: VideoLanguageSet | Array<VideoLanguageSet>;
        /**
         * tag(s) of the video
         */
        tagsOneOf?: string | Array<string>;
        /**
         * tag(s) of the video, where all should be present in the video
         */
        tagsAllOf?: string | Array<string>;
        /**
         * **PeerTube >= 4.0** Display only local or remote objects
         */
        isLocal?: boolean;
        /**
         * **Only administrators and moderators can use this parameter**
         *
         * Include additional videos in results (can be combined using bitwise or operator)
         * - `0` NONE
         * - `1` NOT_PUBLISHED_STATE
         * - `2` BLACKLISTED
         * - `4` BLOCKED_OWNER
         * - `8` FILES
         * - `16` CAPTIONS
         * - `32` VIDEO SOURCE
         *
         */
        include?: 0 | 1 | 2 | 4 | 8 | 16 | 32;
        /**
         * **PeerTube >= 4.0** Display only videos that have HLS files
         */
        hasHLSFiles?: boolean;
        /**
         * **PeerTube >= 6.0** Display only videos that have Web Video files
         */
        hasWebVideoFiles?: boolean;
        /**
         * Find elements owned by this host
         */
        host?: string;
        /**
         * **PeerTube >= 6.2** **Admins and moderators only** filter on videos that contain one of these automatic tags
         */
        autoTagOneOf?: string | Array<string>;
        /**
         * **PeerTube >= 4.0** Display only videos in this specific privacy/privacies
         */
        privacyOneOf?: VideoPrivacySet;
        /**
         * Whether or not to exclude videos that are in the user's video history
         */
        excludeAlreadyWatched?: boolean;
        /**
         * Plain text search, applied to various parts of the model depending on endpoint
         */
        search?: string;
    };
    url: '/api/v1/videos';
};

export type GetVideosResponses = {
    /**
     * successful operation
     */
    200: VideoListResponse;
};

export type GetVideosResponse = GetVideosResponses[keyof GetVideosResponses];

export type GetCategoriesData = {
    body?: never;
    path?: never;
    query?: never;
    url: '/api/v1/videos/categories';
};

export type GetCategoriesResponses = {
    /**
     * successful operation
     */
    200: Array<string>;
};

export type GetCategoriesResponse = GetCategoriesResponses[keyof GetCategoriesResponses];

export type GetLicencesData = {
    body?: never;
    path?: never;
    query?: never;
    url: '/api/v1/videos/licences';
};

export type GetLicencesResponses = {
    /**
     * successful operation
     */
    200: Array<string>;
};

export type GetLicencesResponse = GetLicencesResponses[keyof GetLicencesResponses];

export type GetLanguagesData = {
    body?: never;
    path?: never;
    query?: never;
    url: '/api/v1/videos/languages';
};

export type GetLanguagesResponses = {
    /**
     * successful operation
     */
    200: Array<string>;
};

export type GetLanguagesResponse = GetLanguagesResponses[keyof GetLanguagesResponses];

export type GetVideoPrivacyPoliciesData = {
    body?: never;
    path?: never;
    query?: never;
    url: '/api/v1/videos/privacies';
};

export type GetVideoPrivacyPoliciesResponses = {
    /**
     * successful operation
     */
    200: Array<string>;
};

export type GetVideoPrivacyPoliciesResponse = GetVideoPrivacyPoliciesResponses[keyof GetVideoPrivacyPoliciesResponses];

export type DelVideoData = {
    body?: never;
    path: {
        /**
         * The object id, uuid or short uuid
         */
        id: Id | UuiDv4 | ShortUuid;
    };
    query?: never;
    url: '/api/v1/videos/{id}';
};

export type DelVideoResponses = {
    /**
     * successful operation
     */
    204: void;
};

export type DelVideoResponse = DelVideoResponses[keyof DelVideoResponses];

export type GetVideoData = {
    body?: never;
    headers?: {
        /**
         * Required on password protected video
         */
        'x-peertube-video-password'?: string;
    };
    path: {
        /**
         * The object id, uuid or short uuid
         */
        id: Id | UuiDv4 | ShortUuid;
    };
    query?: never;
    url: '/api/v1/videos/{id}';
};

export type GetVideoErrors = {
    /**
     * provide a correct password to access this password protected video
     */
    403: unknown;
};

export type GetVideoResponses = {
    /**
     * successful operation
     */
    200: VideoDetails;
};

export type GetVideoResponse = GetVideoResponses[keyof GetVideoResponses];

export type PutVideoData = {
    body?: {
        /**
         * New channel of the video. The channel must be owned by the same account as the previous one. Use the "change ownership" endpoints to give a video to a channel owned by another account on the local PeerTube instance.
         */
        channelId?: number;
        /**
         * Video thumbnail file
         */
        thumbnailfile?: Blob | File;
        /**
         * Video preview file
         */
        previewfile?: Blob | File;
        category?: VideoCategorySet;
        licence?: VideoLicenceSet;
        language?: VideoLanguageSet;
        privacy?: VideoPrivacySet;
        /**
         * Video description
         */
        description?: string;
        /**
         * Whether or not we wait transcoding before publish the video
         */
        waitTranscoding?: string;
        /**
         * A text tell the audience how to support the video creator
         */
        support?: string;
        /**
         * Whether or not this video contains sensitive content
         */
        nsfw?: boolean;
        /**
         * More information about the sensitive content of the video
         */
        nsfwSummary?: unknown;
        nsfwFlags?: NsfwFlag;
        /**
         * Video name
         */
        name?: string;
        /**
         * Video tags (maximum 5 tags each between 2 and 30 characters)
         */
        tags?: Array<string>;
        /**
         * Deprecated in 6.2, use commentsPolicy instead
         * @deprecated
         */
        commentsEnabled?: boolean;
        commentsPolicy?: VideoCommentsPolicySet;
        /**
         * Enable or disable downloading for this video
         */
        downloadEnabled?: boolean;
        /**
         * Date when the content was originally published
         */
        originallyPublishedAt?: string | null;
        scheduleUpdate?: VideoScheduledUpdate;
        videoPasswords?: AddVideoPasswords;
    };
    path: {
        /**
         * The object id, uuid or short uuid
         */
        id: Id | UuiDv4 | ShortUuid;
    };
    query?: never;
    url: '/api/v1/videos/{id}';
};

export type PutVideoResponses = {
    /**
     * successful operation
     */
    204: void;
};

export type PutVideoResponse = PutVideoResponses[keyof PutVideoResponses];

export type GetVideoDescData = {
    body?: never;
    headers?: {
        /**
         * Required on password protected video
         */
        'x-peertube-video-password'?: string;
    };
    path: {
        /**
         * The object id, uuid or short uuid
         */
        id: Id | UuiDv4 | ShortUuid;
    };
    query?: never;
    url: '/api/v1/videos/{id}/description';
};

export type GetVideoDescResponses = {
    /**
     * successful operation
     */
    200: string | null;
};

export type GetVideoDescResponse = GetVideoDescResponses[keyof GetVideoDescResponses];

export type AddViewData = {
    body: UserViewingVideo;
    path: {
        /**
         * The object id, uuid or short uuid
         */
        id: Id | UuiDv4 | ShortUuid;
    };
    query?: never;
    url: '/api/v1/videos/{id}/views';
};

export type AddViewResponses = {
    /**
     * successful operation
     */
    204: void;
};

export type AddViewResponse = AddViewResponses[keyof AddViewResponses];

export type PutApiV1VideosByIdWatchingData = {
    body: UserViewingVideo;
    path: {
        /**
         * The object id, uuid or short uuid
         */
        id: Id | UuiDv4 | ShortUuid;
    };
    query?: never;
    url: '/api/v1/videos/{id}/watching';
};

export type PutApiV1VideosByIdWatchingResponses = {
    /**
     * successful operation
     */
    204: void;
};

export type PutApiV1VideosByIdWatchingResponse = PutApiV1VideosByIdWatchingResponses[keyof PutApiV1VideosByIdWatchingResponses];

export type GetApiV1VideosByIdStatsOverallData = {
    body?: never;
    path: {
        /**
         * The object id, uuid or short uuid
         */
        id: Id | UuiDv4 | ShortUuid;
    };
    query?: {
        /**
         * Filter stats by start date
         */
        startDate?: string;
        /**
         * Filter stats by end date
         */
        endDate?: string;
    };
    url: '/api/v1/videos/{id}/stats/overall';
};

export type GetApiV1VideosByIdStatsOverallResponses = {
    /**
     * successful operation
     */
    200: VideoStatsOverall;
};

export type GetApiV1VideosByIdStatsOverallResponse = GetApiV1VideosByIdStatsOverallResponses[keyof GetApiV1VideosByIdStatsOverallResponses];

export type GetApiV1VideosByIdStatsUserAgentData = {
    body?: never;
    path: {
        /**
         * The object id, uuid or short uuid
         */
        id: Id | UuiDv4 | ShortUuid;
    };
    query?: {
        /**
         * Filter stats by start date
         */
        startDate?: string;
        /**
         * Filter stats by end date
         */
        endDate?: string;
    };
    url: '/api/v1/videos/{id}/stats/user-agent';
};

export type GetApiV1VideosByIdStatsUserAgentResponses = {
    /**
     * successful operation
     */
    200: VideoStatsUserAgent;
};

export type GetApiV1VideosByIdStatsUserAgentResponse = GetApiV1VideosByIdStatsUserAgentResponses[keyof GetApiV1VideosByIdStatsUserAgentResponses];

export type GetApiV1VideosByIdStatsRetentionData = {
    body?: never;
    path: {
        /**
         * The object id, uuid or short uuid
         */
        id: Id | UuiDv4 | ShortUuid;
    };
    query?: never;
    url: '/api/v1/videos/{id}/stats/retention';
};

export type GetApiV1VideosByIdStatsRetentionResponses = {
    /**
     * successful operation
     */
    200: VideoStatsRetention;
};

export type GetApiV1VideosByIdStatsRetentionResponse = GetApiV1VideosByIdStatsRetentionResponses[keyof GetApiV1VideosByIdStatsRetentionResponses];

export type GetApiV1VideosByIdStatsTimeseriesByMetricData = {
    body?: never;
    path: {
        /**
         * The object id, uuid or short uuid
         */
        id: Id | UuiDv4 | ShortUuid;
        /**
         * The metric to get
         */
        metric: 'viewers' | 'aggregateWatchTime';
    };
    query?: {
        /**
         * Filter stats by start date
         */
        startDate?: string;
        /**
         * Filter stats by end date
         */
        endDate?: string;
    };
    url: '/api/v1/videos/{id}/stats/timeseries/{metric}';
};

export type GetApiV1VideosByIdStatsTimeseriesByMetricResponses = {
    /**
     * successful operation
     */
    200: VideoStatsTimeserie;
};

export type GetApiV1VideosByIdStatsTimeseriesByMetricResponse = GetApiV1VideosByIdStatsTimeseriesByMetricResponses[keyof GetApiV1VideosByIdStatsTimeseriesByMetricResponses];

export type UploadLegacyData = {
    body?: VideoUploadRequestLegacy;
    path?: never;
    query?: never;
    url: '/api/v1/videos/upload';
};

export type UploadLegacyErrors = {
    /**
     * video didn't pass upload filter
     */
    403: unknown;
    /**
     * upload has timed out
     */
    408: unknown;
    /**
     * If the response has no body, it means the reverse-proxy didn't let it through. Otherwise disambiguate via `code`:
     * - `quota_reached` for quota limits whether daily or global
     *
     */
    413: unknown;
    /**
     * video type unsupported
     */
    415: unknown;
    /**
     * video unreadable
     */
    422: unknown;
};

export type UploadLegacyResponses = {
    /**
     * successful operation
     */
    200: VideoUploadResponse;
};

export type UploadLegacyResponse = UploadLegacyResponses[keyof UploadLegacyResponses];

export type UploadResumableCancelData = {
    body?: never;
    headers: {
        'Content-Length': number;
    };
    path?: never;
    query: {
        /**
         * Created session id to proceed with. If you didn't send chunks in the last hour, it is
         * not valid anymore and you need to initialize a new upload.
         *
         */
        upload_id: string;
    };
    url: '/api/v1/videos/upload-resumable';
};

export type UploadResumableCancelErrors = {
    /**
     * upload not found
     */
    404: unknown;
};

export type UploadResumableCancelResponses = {
    /**
     * upload cancelled
     */
    204: void;
};

export type UploadResumableCancelResponse = UploadResumableCancelResponses[keyof UploadResumableCancelResponses];

export type UploadResumableInitData = {
    body?: VideoUploadRequestResumable;
    headers: {
        /**
         * Number of bytes that will be uploaded in subsequent requests. Set this value to the size of the file you are uploading.
         */
        'X-Upload-Content-Length': number;
        /**
         * MIME type of the file that you are uploading. Depending on your instance settings, acceptable values might vary.
         */
        'X-Upload-Content-Type': string;
    };
    path?: never;
    query?: never;
    url: '/api/v1/videos/upload-resumable';
};

export type UploadResumableInitErrors = {
    /**
     * Disambiguate via `code`:
     * - `max_file_size_reached` for the absolute file size limit
     * - `quota_reached` for quota limits whether daily or global
     *
     */
    413: unknown;
    /**
     * video type unsupported
     */
    415: unknown;
};

export type UploadResumableInitResponses = {
    /**
     * file already exists, send a [`resume`](https://github.com/kukhariev/node-uploadx/blob/master/proto.md) request instead
     */
    200: unknown;
    /**
     * created
     */
    201: unknown;
};

export type UploadResumableData = {
    body?: Blob | File;
    headers: {
        /**
         * Specifies the bytes in the file that the request is uploading.
         *
         * For example, a value of `bytes 0-262143/1000000` shows that the request is sending the first
         * 262144 bytes (256 x 1024) in a 2,469,036 byte file.
         *
         */
        'Content-Range': string;
        /**
         * Size of the chunk that the request is sending.
         *
         * Remember that larger chunks are more efficient. PeerTube's web client uses chunks varying from
         * 1048576 bytes (~1MB) and increases or reduces size depending on connection health.
         *
         */
        'Content-Length': number;
    };
    path?: never;
    query: {
        /**
         * Created session id to proceed with. If you didn't send chunks in the last hour, it is
         * not valid anymore and you need to initialize a new upload.
         *
         */
        upload_id: string;
    };
    url: '/api/v1/videos/upload-resumable';
};

export type UploadResumableErrors = {
    /**
     * video didn't pass upload filter
     */
    403: unknown;
    /**
     * upload not found
     */
    404: unknown;
    /**
     * chunk doesn't match range
     */
    409: unknown;
    /**
     * video unreadable
     */
    422: unknown;
    /**
     * too many concurrent requests
     */
    429: unknown;
    /**
     * upload is already being processed
     */
    503: unknown;
};

export type UploadResumableResponses = {
    /**
     * last chunk received
     */
    200: VideoUploadResponse;
};

export type UploadResumableResponse = UploadResumableResponses[keyof UploadResumableResponses];

export type ImportVideoData = {
    body?: VideoCreateImport;
    path?: never;
    query?: never;
    url: '/api/v1/videos/imports';
};

export type ImportVideoErrors = {
    /**
     * `magnetUri` or `targetUrl` or a torrent file missing
     */
    400: unknown;
    /**
     * video didn't pass pre-import filter
     */
    403: unknown;
    /**
     * HTTP or Torrent/magnetURI import not enabled
     */
    409: unknown;
};

export type ImportVideoResponses = {
    /**
     * successful operation
     */
    200: VideoUploadResponse;
};

export type ImportVideoResponse = ImportVideoResponses[keyof ImportVideoResponses];

export type PostApiV1VideosImportsByIdCancelData = {
    body?: never;
    path: {
        /**
         * Entity id
         */
        id: Id;
    };
    query?: never;
    url: '/api/v1/videos/imports/{id}/cancel';
};

export type PostApiV1VideosImportsByIdCancelResponses = {
    /**
     * successful operation
     */
    204: void;
};

export type PostApiV1VideosImportsByIdCancelResponse = PostApiV1VideosImportsByIdCancelResponses[keyof PostApiV1VideosImportsByIdCancelResponses];

export type DeleteApiV1VideosImportsByIdData = {
    body?: never;
    path: {
        /**
         * Entity id
         */
        id: Id;
    };
    query?: never;
    url: '/api/v1/videos/imports/{id}';
};

export type DeleteApiV1VideosImportsByIdResponses = {
    /**
     * successful operation
     */
    204: void;
};

export type DeleteApiV1VideosImportsByIdResponse = DeleteApiV1VideosImportsByIdResponses[keyof DeleteApiV1VideosImportsByIdResponses];

export type AddLiveData = {
    body?: {
        /**
         * Channel id that will contain this live video
         */
        channelId: number;
        saveReplay?: boolean;
        replaySettings?: LiveVideoReplaySettings;
        /**
         * User can stream multiple times in a permanent live
         */
        permanentLive?: boolean;
        /**
         * User can select live latency mode if enabled by the instance
         */
        latencyMode?: LiveVideoLatencyMode;
        /**
         * Live video/replay thumbnail file
         */
        thumbnailfile?: Blob | File;
        /**
         * Live video/replay preview file
         */
        previewfile?: Blob | File;
        privacy?: VideoPrivacySet;
        category?: VideoCategorySet;
        licence?: VideoLicenceSet;
        language?: VideoLanguageSet;
        /**
         * Live video/replay description
         */
        description?: string;
        /**
         * A text tell the audience how to support the creator
         */
        support?: string;
        /**
         * Whether or not this live video/replay contains sensitive content
         */
        nsfw?: boolean;
        /**
         * More information about the sensitive content of the video
         */
        nsfwSummary?: unknown;
        nsfwFlags?: NsfwFlag;
        /**
         * Live video/replay name
         */
        name: string;
        /**
         * Live video/replay tags (maximum 5 tags each between 2 and 30 characters)
         */
        tags?: Array<string>;
        /**
         * Deprecated in 6.2, use commentsPolicy instead
         * @deprecated
         */
        commentsEnabled?: boolean;
        commentsPolicy?: VideoCommentsPolicySet;
        /**
         * Enable or disable downloading for the replay of this live video
         */
        downloadEnabled?: boolean;
        schedules?: Array<LiveSchedule>;
    };
    path?: never;
    query?: never;
    url: '/api/v1/videos/live';
};

export type AddLiveErrors = {
    /**
     * Disambiguate via `code`:
     * - default type for a validation error
     * - `live_conflicting_permanent_and_save_replay` for conflicting parameters set
     *
     */
    400: unknown;
    /**
     * Disambiguate via `code`:
     * - `live_not_enabled` for a disabled live feature
     * - `live_not_allowing_replay` for a disabled replay feature
     * - `max_instance_lives_limit_reached` for the absolute concurrent live limit
     * - `max_user_lives_limit_reached` for the user concurrent live limit
     *
     */
    403: unknown;
};

export type AddLiveResponses = {
    /**
     * successful operation
     */
    200: VideoUploadResponse;
};

export type AddLiveResponse = AddLiveResponses[keyof AddLiveResponses];

export type GetLiveIdData = {
    body?: never;
    path: {
        /**
         * The object id, uuid or short uuid
         */
        id: Id | UuiDv4 | ShortUuid;
    };
    query?: never;
    url: '/api/v1/videos/live/{id}';
};

export type GetLiveIdResponses = {
    /**
     * successful operation
     */
    200: LiveVideoResponse;
};

export type GetLiveIdResponse = GetLiveIdResponses[keyof GetLiveIdResponses];

export type UpdateLiveIdData = {
    body?: LiveVideoUpdate;
    path: {
        /**
         * The object id, uuid or short uuid
         */
        id: Id | UuiDv4 | ShortUuid;
    };
    query?: never;
    url: '/api/v1/videos/live/{id}';
};

export type UpdateLiveIdErrors = {
    /**
     * bad parameters or trying to update a live that has already started
     */
    400: unknown;
    /**
     * trying to save replay of the live but saving replay is not enabled on the instance
     */
    403: unknown;
};

export type UpdateLiveIdResponses = {
    /**
     * successful operation
     */
    204: void;
};

export type UpdateLiveIdResponse = UpdateLiveIdResponses[keyof UpdateLiveIdResponses];

export type GetApiV1VideosLiveByIdSessionsData = {
    body?: never;
    path: {
        /**
         * The object id, uuid or short uuid
         */
        id: Id | UuiDv4 | ShortUuid;
    };
    query?: never;
    url: '/api/v1/videos/live/{id}/sessions';
};

export type GetApiV1VideosLiveByIdSessionsResponses = {
    /**
     * successful operation
     */
    200: {
        total?: number;
        data?: Array<LiveVideoSessionResponse>;
    };
};

export type GetApiV1VideosLiveByIdSessionsResponse = GetApiV1VideosLiveByIdSessionsResponses[keyof GetApiV1VideosLiveByIdSessionsResponses];

export type GetApiV1VideosByIdLiveSessionData = {
    body?: never;
    headers?: {
        /**
         * Required on password protected video
         */
        'x-peertube-video-password'?: string;
    };
    path: {
        /**
         * The object id, uuid or short uuid
         */
        id: Id | UuiDv4 | ShortUuid;
    };
    query?: never;
    url: '/api/v1/videos/{id}/live-session';
};

export type GetApiV1VideosByIdLiveSessionResponses = {
    /**
     * successful operation
     */
    200: LiveVideoSessionResponse;
};

export type GetApiV1VideosByIdLiveSessionResponse = GetApiV1VideosByIdLiveSessionResponses[keyof GetApiV1VideosByIdLiveSessionResponses];

export type GetVideoSourceData = {
    body?: never;
    path: {
        /**
         * The object id, uuid or short uuid
         */
        id: Id | UuiDv4 | ShortUuid;
    };
    query?: never;
    url: '/api/v1/videos/{id}/source';
};

export type GetVideoSourceResponses = {
    /**
     * successful operation
     */
    200: VideoSource;
};

export type GetVideoSourceResponse = GetVideoSourceResponses[keyof GetVideoSourceResponses];

export type DeleteVideoSourceFileData = {
    body?: never;
    path: {
        /**
         * The object id, uuid or short uuid
         */
        id: Id | UuiDv4 | ShortUuid;
    };
    query?: never;
    url: '/api/v1/videos/{id}/source/file';
};

export type DeleteVideoSourceFileErrors = {
    /**
     * video source not found
     */
    404: unknown;
};

export type DeleteVideoSourceFileResponses = {
    /**
     * successful operation
     */
    204: void;
};

export type DeleteVideoSourceFileResponse = DeleteVideoSourceFileResponses[keyof DeleteVideoSourceFileResponses];

export type ReplaceVideoSourceResumableCancelData = {
    body?: never;
    headers: {
        'Content-Length': number;
    };
    path: {
        /**
         * The object id, uuid or short uuid
         */
        id: Id | UuiDv4 | ShortUuid;
    };
    query: {
        /**
         * Created session id to proceed with. If you didn't send chunks in the last hour, it is
         * not valid anymore and you need to initialize a new upload.
         *
         */
        upload_id: string;
    };
    url: '/api/v1/videos/{id}/source/replace-resumable';
};

export type ReplaceVideoSourceResumableCancelErrors = {
    /**
     * source file replacement not found
     */
    404: unknown;
};

export type ReplaceVideoSourceResumableCancelResponses = {
    /**
     * source file replacement cancelled
     */
    204: void;
};

export type ReplaceVideoSourceResumableCancelResponse = ReplaceVideoSourceResumableCancelResponses[keyof ReplaceVideoSourceResumableCancelResponses];

export type ReplaceVideoSourceResumableInitData = {
    body?: VideoReplaceSourceRequestResumable;
    headers: {
        /**
         * Number of bytes that will be uploaded in subsequent requests. Set this value to the size of the file you are uploading.
         */
        'X-Upload-Content-Length': number;
        /**
         * MIME type of the file that you are uploading. Depending on your instance settings, acceptable values might vary.
         */
        'X-Upload-Content-Type': string;
    };
    path: {
        /**
         * The object id, uuid or short uuid
         */
        id: Id | UuiDv4 | ShortUuid;
    };
    query?: never;
    url: '/api/v1/videos/{id}/source/replace-resumable';
};

export type ReplaceVideoSourceResumableInitErrors = {
    /**
     * Disambiguate via `code`:
     * - `max_file_size_reached` for the absolute file size limit
     * - `quota_reached` for quota limits whether daily or global
     *
     */
    413: unknown;
    /**
     * video type unsupported
     */
    415: unknown;
};

export type ReplaceVideoSourceResumableInitResponses = {
    /**
     * file already exists, send a [`resume`](https://github.com/kukhariev/node-uploadx/blob/master/proto.md) request instead
     */
    200: unknown;
    /**
     * created
     */
    201: unknown;
};

export type ReplaceVideoSourceResumableData = {
    body?: Blob | File;
    headers: {
        /**
         * Specifies the bytes in the file that the request is uploading.
         *
         * For example, a value of `bytes 0-262143/1000000` shows that the request is sending the first
         * 262144 bytes (256 x 1024) in a 2,469,036 byte file.
         *
         */
        'Content-Range': string;
        /**
         * Size of the chunk that the request is sending.
         *
         * Remember that larger chunks are more efficient. PeerTube's web client uses chunks varying from
         * 1048576 bytes (~1MB) and increases or reduces size depending on connection health.
         *
         */
        'Content-Length': number;
    };
    path: {
        /**
         * The object id, uuid or short uuid
         */
        id: Id | UuiDv4 | ShortUuid;
    };
    query: {
        /**
         * Created session id to proceed with. If you didn't send chunks in the last hour, it is
         * not valid anymore and you need to initialize a new upload.
         *
         */
        upload_id: string;
    };
    url: '/api/v1/videos/{id}/source/replace-resumable';
};

export type ReplaceVideoSourceResumableErrors = {
    /**
     * video didn't pass file replacement filter
     */
    403: unknown;
    /**
     * replace upload not found
     */
    404: unknown;
    /**
     * chunk doesn't match range
     */
    409: unknown;
    /**
     * video unreadable
     */
    422: unknown;
    /**
     * too many concurrent requests
     */
    429: unknown;
    /**
     * upload is already being processed
     */
    503: unknown;
};

export type ReplaceVideoSourceResumableResponses = {
    /**
     * last chunk received: successful operation
     */
    204: void;
};

export type ReplaceVideoSourceResumableResponse = ReplaceVideoSourceResumableResponses[keyof ReplaceVideoSourceResumableResponses];

export type GetMyAbusesData = {
    body?: never;
    path?: never;
    query?: {
        /**
         * only list the report with this id
         */
        id?: number;
        state?: AbuseStateSet;
        /**
         * Sort abuses by criteria
         */
        sort?: '-id' | '-createdAt' | '-state';
        /**
         * Offset used to paginate results
         */
        start?: number;
        /**
         * Number of items to return
         */
        count?: number;
    };
    url: '/api/v1/users/me/abuses';
};

export type GetMyAbusesResponses = {
    /**
     * successful operation
     */
    200: {
        total?: number;
        data?: Array<Abuse>;
    };
};

export type GetMyAbusesResponse = GetMyAbusesResponses[keyof GetMyAbusesResponses];

export type GetAbusesData = {
    body?: never;
    path?: never;
    query?: {
        /**
         * only list the report with this id
         */
        id?: number;
        /**
         * predefined reason the listed reports should contain
         */
        predefinedReason?: PredefinedAbuseReasons;
        /**
         * plain search that will match with video titles, reporter names and more
         */
        search?: string;
        state?: AbuseStateSet;
        /**
         * only list reports of a specific reporter
         */
        searchReporter?: string;
        /**
         * only list reports of a specific reportee
         */
        searchReportee?: string;
        /**
         * only list reports of a specific video
         */
        searchVideo?: string;
        /**
         * only list reports of a specific video channel
         */
        searchVideoChannel?: string;
        /**
         * only list deleted or blocklisted videos
         */
        videoIs?: 'deleted' | 'blacklisted';
        /**
         * only list account, comment or video reports
         */
        filter?: 'video' | 'comment' | 'account';
        /**
         * Offset used to paginate results
         */
        start?: number;
        /**
         * Number of items to return
         */
        count?: number;
        /**
         * Sort abuses by criteria
         */
        sort?: '-id' | '-createdAt' | '-state';
    };
    url: '/api/v1/abuses';
};

export type GetAbusesResponses = {
    /**
     * successful operation
     */
    200: {
        total?: number;
        data?: Array<Abuse>;
    };
};

export type GetAbusesResponse = GetAbusesResponses[keyof GetAbusesResponses];

export type PostApiV1AbusesData = {
    body: {
        /**
         * Reason why the user reports this video
         */
        reason: string;
        predefinedReasons?: PredefinedAbuseReasons;
        video?: {
            /**
             * Video id to report
             */
            id?: 8;
            /**
             * Timestamp in the video that marks the beginning of the report
             */
            startAt?: number;
            /**
             * Timestamp in the video that marks the ending of the report
             */
            endAt?: number;
        };
        comment?: {
            /**
             * Comment id to report
             */
            id?: Id;
        };
        account?: {
            /**
             * Account id to report
             */
            id?: number;
        };
    };
    path?: never;
    query?: never;
    url: '/api/v1/abuses';
};

export type PostApiV1AbusesErrors = {
    /**
     * incorrect request parameters
     */
    400: unknown;
};

export type PostApiV1AbusesResponses = {
    /**
     * successful operation
     */
    200: {
        abuse?: {
            id?: Id;
        };
    };
};

export type PostApiV1AbusesResponse = PostApiV1AbusesResponses[keyof PostApiV1AbusesResponses];

export type DeleteApiV1AbusesByAbuseIdData = {
    body?: never;
    path: {
        /**
         * Abuse id
         */
        abuseId: Id;
    };
    query?: never;
    url: '/api/v1/abuses/{abuseId}';
};

export type DeleteApiV1AbusesByAbuseIdErrors = {
    /**
     * block not found
     */
    404: unknown;
};

export type DeleteApiV1AbusesByAbuseIdResponses = {
    /**
     * successful operation
     */
    204: void;
};

export type DeleteApiV1AbusesByAbuseIdResponse = DeleteApiV1AbusesByAbuseIdResponses[keyof DeleteApiV1AbusesByAbuseIdResponses];

export type PutApiV1AbusesByAbuseIdData = {
    body?: {
        state?: AbuseStateSet;
        /**
         * Update the report comment visible only to the moderation team
         */
        moderationComment?: string;
    };
    path: {
        /**
         * Abuse id
         */
        abuseId: Id;
    };
    query?: never;
    url: '/api/v1/abuses/{abuseId}';
};

export type PutApiV1AbusesByAbuseIdErrors = {
    /**
     * abuse not found
     */
    404: unknown;
};

export type PutApiV1AbusesByAbuseIdResponses = {
    /**
     * successful operation
     */
    204: void;
};

export type PutApiV1AbusesByAbuseIdResponse = PutApiV1AbusesByAbuseIdResponses[keyof PutApiV1AbusesByAbuseIdResponses];

export type GetApiV1AbusesByAbuseIdMessagesData = {
    body?: never;
    path: {
        /**
         * Abuse id
         */
        abuseId: Id;
    };
    query?: never;
    url: '/api/v1/abuses/{abuseId}/messages';
};

export type GetApiV1AbusesByAbuseIdMessagesResponses = {
    /**
     * successful operation
     */
    200: {
        total?: number;
        data?: Array<AbuseMessage>;
    };
};

export type GetApiV1AbusesByAbuseIdMessagesResponse = GetApiV1AbusesByAbuseIdMessagesResponses[keyof GetApiV1AbusesByAbuseIdMessagesResponses];

export type PostApiV1AbusesByAbuseIdMessagesData = {
    body: {
        /**
         * Message to send
         */
        message: string;
    };
    path: {
        /**
         * Abuse id
         */
        abuseId: Id;
    };
    query?: never;
    url: '/api/v1/abuses/{abuseId}/messages';
};

export type PostApiV1AbusesByAbuseIdMessagesErrors = {
    /**
     * incorrect request parameters
     */
    400: unknown;
};

export type PostApiV1AbusesByAbuseIdMessagesResponses = {
    /**
     * successful operation
     */
    200: unknown;
};

export type DeleteApiV1AbusesByAbuseIdMessagesByAbuseMessageIdData = {
    body?: never;
    path: {
        /**
         * Abuse id
         */
        abuseId: Id;
        /**
         * Abuse message id
         */
        abuseMessageId: Id;
    };
    query?: never;
    url: '/api/v1/abuses/{abuseId}/messages/{abuseMessageId}';
};

export type DeleteApiV1AbusesByAbuseIdMessagesByAbuseMessageIdResponses = {
    /**
     * successful operation
     */
    204: void;
};

export type DeleteApiV1AbusesByAbuseIdMessagesByAbuseMessageIdResponse = DeleteApiV1AbusesByAbuseIdMessagesByAbuseMessageIdResponses[keyof DeleteApiV1AbusesByAbuseIdMessagesByAbuseMessageIdResponses];

export type DelVideoBlockData = {
    body?: never;
    path: {
        /**
         * The object id, uuid or short uuid
         */
        id: Id | UuiDv4 | ShortUuid;
    };
    query?: never;
    url: '/api/v1/videos/{id}/blacklist';
};

export type DelVideoBlockErrors = {
    /**
     * block not found
     */
    404: unknown;
};

export type DelVideoBlockResponses = {
    /**
     * successful operation
     */
    204: void;
};

export type DelVideoBlockResponse = DelVideoBlockResponses[keyof DelVideoBlockResponses];

export type AddVideoBlockData = {
    body?: never;
    path: {
        /**
         * The object id, uuid or short uuid
         */
        id: Id | UuiDv4 | ShortUuid;
    };
    query?: never;
    url: '/api/v1/videos/{id}/blacklist';
};

export type AddVideoBlockResponses = {
    /**
     * successful operation
     */
    204: void;
};

export type AddVideoBlockResponse = AddVideoBlockResponses[keyof AddVideoBlockResponses];

export type GetVideoBlocksData = {
    body?: never;
    path?: never;
    query?: {
        /**
         * list only blocks that match this type:
         * - `1`: manual block
         * - `2`: automatic block that needs review
         *
         */
        type?: 1 | 2;
        /**
         * plain search that will match with video titles, and more
         */
        search?: string;
        /**
         * Offset used to paginate results
         */
        start?: number;
        /**
         * Number of items to return
         */
        count?: number;
        /**
         * Sort blocklists by criteria
         */
        sort?: '-id' | 'name' | '-duration' | '-views' | '-likes' | '-dislikes' | '-uuid' | '-createdAt';
    };
    url: '/api/v1/videos/blacklist';
};

export type GetVideoBlocksResponses = {
    /**
     * successful operation
     */
    200: {
        total?: number;
        data?: Array<VideoBlacklist>;
    };
};

export type GetVideoBlocksResponse = GetVideoBlocksResponses[keyof GetVideoBlocksResponses];

export type ListVideoStoryboardsData = {
    body?: never;
    path: {
        /**
         * The object id, uuid or short uuid
         */
        id: Id | UuiDv4 | ShortUuid;
    };
    query?: never;
    url: '/api/v1/videos/{id}/storyboards';
};

export type ListVideoStoryboardsResponses = {
    /**
     * successful operation
     */
    200: {
        storyboards?: Array<Storyboard>;
    };
};

export type ListVideoStoryboardsResponse = ListVideoStoryboardsResponses[keyof ListVideoStoryboardsResponses];

export type GetVideoCaptionsData = {
    body?: never;
    headers?: {
        /**
         * Required on password protected video
         */
        'x-peertube-video-password'?: string;
    };
    path: {
        /**
         * The object id, uuid or short uuid
         */
        id: Id | UuiDv4 | ShortUuid;
    };
    query?: never;
    url: '/api/v1/videos/{id}/captions';
};

export type GetVideoCaptionsResponses = {
    /**
     * successful operation
     */
    200: {
        total?: number;
        data?: Array<VideoCaption>;
    };
};

export type GetVideoCaptionsResponse = GetVideoCaptionsResponses[keyof GetVideoCaptionsResponses];

export type GenerateVideoCaptionData = {
    body?: {
        forceTranscription?: boolean;
    };
    path: {
        /**
         * The object id, uuid or short uuid
         */
        id: Id | UuiDv4 | ShortUuid;
    };
    query?: never;
    url: '/api/v1/videos/{id}/captions/generate';
};

export type GenerateVideoCaptionErrors = {
    /**
     * video not found
     */
    404: unknown;
};

export type GenerateVideoCaptionResponses = {
    /**
     * successful operation
     */
    204: void;
};

export type GenerateVideoCaptionResponse = GenerateVideoCaptionResponses[keyof GenerateVideoCaptionResponses];

export type DelVideoCaptionData = {
    body?: never;
    path: {
        /**
         * The object id, uuid or short uuid
         */
        id: Id | UuiDv4 | ShortUuid;
        /**
         * The caption language
         */
        captionLanguage: VideoLanguageSet;
    };
    query?: never;
    url: '/api/v1/videos/{id}/captions/{captionLanguage}';
};

export type DelVideoCaptionErrors = {
    /**
     * video or language or caption for that language not found
     */
    404: unknown;
};

export type DelVideoCaptionResponses = {
    /**
     * successful operation
     */
    204: void;
};

export type DelVideoCaptionResponse = DelVideoCaptionResponses[keyof DelVideoCaptionResponses];

export type AddVideoCaptionData = {
    body?: {
        /**
         * The file to upload.
         */
        captionfile?: Blob | File;
    };
    path: {
        /**
         * The object id, uuid or short uuid
         */
        id: Id | UuiDv4 | ShortUuid;
        /**
         * The caption language
         */
        captionLanguage: VideoLanguageSet;
    };
    query?: never;
    url: '/api/v1/videos/{id}/captions/{captionLanguage}';
};

export type AddVideoCaptionErrors = {
    /**
     * video or language not found
     */
    404: unknown;
};

export type AddVideoCaptionResponses = {
    /**
     * successful operation
     */
    204: void;
};

export type AddVideoCaptionResponse = AddVideoCaptionResponses[keyof AddVideoCaptionResponses];

export type GetVideoChaptersData = {
    body?: never;
    headers?: {
        /**
         * Required on password protected video
         */
        'x-peertube-video-password'?: string;
    };
    path: {
        /**
         * The object id, uuid or short uuid
         */
        id: Id | UuiDv4 | ShortUuid;
    };
    query?: never;
    url: '/api/v1/videos/{id}/chapters';
};

export type GetVideoChaptersResponses = {
    /**
     * successful operation
     */
    200: VideoChapters;
};

export type GetVideoChaptersResponse = GetVideoChaptersResponses[keyof GetVideoChaptersResponses];

export type ReplaceVideoChaptersData = {
    body?: {
        chapters?: Array<{
            title?: string;
            timecode?: number;
        }>;
    };
    path: {
        /**
         * The object id, uuid or short uuid
         */
        id: Id | UuiDv4 | ShortUuid;
    };
    query?: never;
    url: '/api/v1/videos/{id}/chapters';
};

export type ReplaceVideoChaptersErrors = {
    /**
     * video not found
     */
    404: unknown;
};

export type ReplaceVideoChaptersResponses = {
    /**
     * successful operation
     */
    204: void;
};

export type ReplaceVideoChaptersResponse = ReplaceVideoChaptersResponses[keyof ReplaceVideoChaptersResponses];

export type GetApiV1VideosByIdPasswordsData = {
    body?: never;
    path: {
        /**
         * The object id, uuid or short uuid
         */
        id: Id | UuiDv4 | ShortUuid;
    };
    query?: {
        /**
         * Offset used to paginate results
         */
        start?: number;
        /**
         * Number of items to return
         */
        count?: number;
        /**
         * Sort column
         */
        sort?: string;
    };
    url: '/api/v1/videos/{id}/passwords';
};

export type GetApiV1VideosByIdPasswordsErrors = {
    /**
     * video is not password protected
     */
    400: unknown;
};

export type GetApiV1VideosByIdPasswordsResponses = {
    /**
     * successful operation
     */
    204: VideoPasswordList;
};

export type GetApiV1VideosByIdPasswordsResponse = GetApiV1VideosByIdPasswordsResponses[keyof GetApiV1VideosByIdPasswordsResponses];

export type PutApiV1VideosByIdPasswordsData = {
    body?: {
        passwords?: AddVideoPasswords;
    };
    path: {
        /**
         * The object id, uuid or short uuid
         */
        id: Id | UuiDv4 | ShortUuid;
    };
    query?: never;
    url: '/api/v1/videos/{id}/passwords';
};

export type PutApiV1VideosByIdPasswordsErrors = {
    /**
     * video is not password protected
     */
    400: unknown;
};

export type PutApiV1VideosByIdPasswordsResponses = {
    /**
     * successful operation
     */
    204: void;
};

export type PutApiV1VideosByIdPasswordsResponse = PutApiV1VideosByIdPasswordsResponses[keyof PutApiV1VideosByIdPasswordsResponses];

export type DeleteApiV1VideosByIdPasswordsByVideoPasswordIdData = {
    body?: never;
    path: {
        /**
         * The object id, uuid or short uuid
         */
        id: Id | UuiDv4 | ShortUuid;
        /**
         * The video password id
         */
        videoPasswordId: Id;
    };
    query?: never;
    url: '/api/v1/videos/{id}/passwords/{videoPasswordId}';
};

export type DeleteApiV1VideosByIdPasswordsByVideoPasswordIdErrors = {
    /**
     * video is not password protected
     */
    400: unknown;
    /**
     * cannot delete the last password of the protected video
     */
    403: unknown;
};

export type DeleteApiV1VideosByIdPasswordsByVideoPasswordIdResponses = {
    /**
     * successful operation
     */
    204: void;
};

export type DeleteApiV1VideosByIdPasswordsByVideoPasswordIdResponse = DeleteApiV1VideosByIdPasswordsByVideoPasswordIdResponses[keyof DeleteApiV1VideosByIdPasswordsByVideoPasswordIdResponses];

export type GetVideoChannelsData = {
    body?: never;
    path?: never;
    query?: {
        /**
         * Offset used to paginate results
         */
        start?: number;
        /**
         * Number of items to return
         */
        count?: number;
        /**
         * Sort column
         */
        sort?: string;
    };
    url: '/api/v1/video-channels';
};

export type GetVideoChannelsResponses = {
    /**
     * successful operation
     */
    200: VideoChannelList;
};

export type GetVideoChannelsResponse = GetVideoChannelsResponses[keyof GetVideoChannelsResponses];

export type AddVideoChannelData = {
    body?: VideoChannelCreate;
    path?: never;
    query?: never;
    url: '/api/v1/video-channels';
};

export type AddVideoChannelResponses = {
    /**
     * successful operation
     */
    200: {
        videoChannel?: {
            id?: Id;
        };
    };
};

export type AddVideoChannelResponse = AddVideoChannelResponses[keyof AddVideoChannelResponses];

export type DelVideoChannelData = {
    body?: never;
    path: {
        /**
         * The video channel handle
         */
        channelHandle: string;
    };
    query?: never;
    url: '/api/v1/video-channels/{channelHandle}';
};

export type DelVideoChannelResponses = {
    /**
     * successful operation
     */
    204: void;
};

export type DelVideoChannelResponse = DelVideoChannelResponses[keyof DelVideoChannelResponses];

export type GetVideoChannelData = {
    body?: never;
    path: {
        /**
         * The video channel handle
         */
        channelHandle: string;
    };
    query?: never;
    url: '/api/v1/video-channels/{channelHandle}';
};

export type GetVideoChannelResponses = {
    /**
     * successful operation
     */
    200: VideoChannel;
};

export type GetVideoChannelResponse = GetVideoChannelResponses[keyof GetVideoChannelResponses];

export type PutVideoChannelData = {
    body?: VideoChannelUpdate;
    path: {
        /**
         * The video channel handle
         */
        channelHandle: string;
    };
    query?: never;
    url: '/api/v1/video-channels/{channelHandle}';
};

export type PutVideoChannelResponses = {
    /**
     * successful operation
     */
    204: void;
};

export type PutVideoChannelResponse = PutVideoChannelResponses[keyof PutVideoChannelResponses];

export type GetVideoChannelVideosData = {
    body?: never;
    path: {
        /**
         * The video channel handle
         */
        channelHandle: string;
    };
    query?: {
        /**
         * Offset used to paginate results
         */
        start?: number;
        /**
         * Number of items to return
         */
        count?: number;
        /**
         * if you don't need the `total` in the response
         */
        skipCount?: 'true' | 'false';
        /**
         * Sort videos by criteria (prefixing with `-` means `DESC` order):
         * * `hot` - Adaptation of Reddit "hot" algorithm taking into account video views, likes, dislikes and comments and publication date
         * * `best` - Same than `hot`, but also takes into account user video history
         * * `trending` - Sort videos by recent views ("recent" is defined by the admin)
         * * `views` - Sort videos using their `views` counter
         * * `publishedAt` - Sort by video publication date (when it became publicly available)
         *
         */
        sort?: 'name' | '-duration' | '-createdAt' | '-publishedAt' | '-views' | '-likes' | '-comments' | '-trending' | '-hot' | '-best';
        /**
         * whether to include nsfw videos, if any
         */
        nsfw?: 'true' | 'false';
        nsfwFlagsIncluded?: NsfwFlag;
        nsfwFlagsExcluded?: NsfwFlag;
        /**
         * whether or not the video is a live
         */
        isLive?: boolean;
        /**
         * whether or not include live that are scheduled for later
         */
        includeScheduledLive?: boolean;
        /**
         * category id of the video (see [/videos/categories](#operation/getCategories))
         */
        categoryOneOf?: VideoCategorySet | Array<VideoCategorySet>;
        /**
         * licence id of the video (see [/videos/licences](#operation/getLicences))
         */
        licenceOneOf?: VideoLicenceSet | Array<VideoLicenceSet>;
        /**
         * language id of the video (see [/videos/languages](#operation/getLanguages)). Use `_unknown` to filter on videos that don't have a video language
         */
        languageOneOf?: VideoLanguageSet | Array<VideoLanguageSet>;
        /**
         * tag(s) of the video
         */
        tagsOneOf?: string | Array<string>;
        /**
         * tag(s) of the video, where all should be present in the video
         */
        tagsAllOf?: string | Array<string>;
        /**
         * **PeerTube >= 4.0** Display only local or remote objects
         */
        isLocal?: boolean;
        /**
         * **Only administrators and moderators can use this parameter**
         *
         * Include additional videos in results (can be combined using bitwise or operator)
         * - `0` NONE
         * - `1` NOT_PUBLISHED_STATE
         * - `2` BLACKLISTED
         * - `4` BLOCKED_OWNER
         * - `8` FILES
         * - `16` CAPTIONS
         * - `32` VIDEO SOURCE
         *
         */
        include?: 0 | 1 | 2 | 4 | 8 | 16 | 32;
        /**
         * **PeerTube >= 4.0** Display only videos that have HLS files
         */
        hasHLSFiles?: boolean;
        /**
         * **PeerTube >= 6.0** Display only videos that have Web Video files
         */
        hasWebVideoFiles?: boolean;
        /**
         * Find elements owned by this host
         */
        host?: string;
        /**
         * **PeerTube >= 6.2** **Admins and moderators only** filter on videos that contain one of these automatic tags
         */
        autoTagOneOf?: string | Array<string>;
        /**
         * **PeerTube >= 4.0** Display only videos in this specific privacy/privacies
         */
        privacyOneOf?: VideoPrivacySet;
        /**
         * Whether or not to exclude videos that are in the user's video history
         */
        excludeAlreadyWatched?: boolean;
        /**
         * Plain text search, applied to various parts of the model depending on endpoint
         */
        search?: string;
    };
    url: '/api/v1/video-channels/{channelHandle}/videos';
};

export type GetVideoChannelVideosResponses = {
    /**
     * successful operation
     */
    200: VideoListResponse;
};

export type GetVideoChannelVideosResponse = GetVideoChannelVideosResponses[keyof GetVideoChannelVideosResponses];

export type GetApiV1VideoChannelsByChannelHandleVideoPlaylistsData = {
    body?: never;
    path: {
        /**
         * The video channel handle
         */
        channelHandle: string;
    };
    query?: {
        /**
         * Offset used to paginate results
         */
        start?: number;
        /**
         * Number of items to return
         */
        count?: number;
        /**
         * Sort column
         */
        sort?: string;
        playlistType?: VideoPlaylistTypeSet;
    };
    url: '/api/v1/video-channels/{channelHandle}/video-playlists';
};

export type GetApiV1VideoChannelsByChannelHandleVideoPlaylistsResponses = {
    /**
     * successful operation
     */
    200: {
        total?: number;
        data?: Array<VideoPlaylist>;
    };
};

export type GetApiV1VideoChannelsByChannelHandleVideoPlaylistsResponse = GetApiV1VideoChannelsByChannelHandleVideoPlaylistsResponses[keyof GetApiV1VideoChannelsByChannelHandleVideoPlaylistsResponses];

export type ReorderVideoPlaylistsOfChannelData = {
    body?: {
        /**
         * Start position of the element to reorder
         */
        startPosition: number;
        /**
         * New position for the block to reorder, to add the block before the first element
         */
        insertAfterPosition: number;
        /**
         * How many element from `startPosition` to reorder
         */
        reorderLength?: number;
    };
    path: {
        /**
         * The video channel handle
         */
        channelHandle: string;
    };
    query?: never;
    url: '/api/v1/video-channels/{channelHandle}/video-playlists/reorder';
};

export type ReorderVideoPlaylistsOfChannelResponses = {
    /**
     * successful operation
     */
    204: void;
};

export type ReorderVideoPlaylistsOfChannelResponse = ReorderVideoPlaylistsOfChannelResponses[keyof ReorderVideoPlaylistsOfChannelResponses];

export type GetVideoChannelFollowersData = {
    body?: never;
    path: {
        /**
         * The video channel handle
         */
        channelHandle: string;
    };
    query?: {
        /**
         * Offset used to paginate results
         */
        start?: number;
        /**
         * Number of items to return
         */
        count?: number;
        /**
         * Sort followers by criteria
         */
        sort?: 'createdAt';
        /**
         * Plain text search, applied to various parts of the model depending on endpoint
         */
        search?: string;
    };
    url: '/api/v1/video-channels/{channelHandle}/followers';
};

export type GetVideoChannelFollowersResponses = {
    /**
     * successful operation
     */
    200: {
        total?: number;
        data?: Array<Follow>;
    };
};

export type GetVideoChannelFollowersResponse = GetVideoChannelFollowersResponses[keyof GetVideoChannelFollowersResponses];

export type PostApiV1VideoChannelsByChannelHandleAvatarPickData = {
    body?: {
        /**
         * The file to upload.
         */
        avatarfile?: Blob | File;
    };
    path: {
        /**
         * The video channel handle
         */
        channelHandle: string;
    };
    query?: never;
    url: '/api/v1/video-channels/{channelHandle}/avatar/pick';
};

export type PostApiV1VideoChannelsByChannelHandleAvatarPickErrors = {
    /**
     * image file too large
     */
    413: unknown;
};

export type PostApiV1VideoChannelsByChannelHandleAvatarPickResponses = {
    /**
     * successful operation
     */
    200: {
        avatars?: Array<ActorImage>;
    };
};

export type PostApiV1VideoChannelsByChannelHandleAvatarPickResponse = PostApiV1VideoChannelsByChannelHandleAvatarPickResponses[keyof PostApiV1VideoChannelsByChannelHandleAvatarPickResponses];

export type DeleteApiV1VideoChannelsByChannelHandleAvatarData = {
    body?: never;
    path: {
        /**
         * The video channel handle
         */
        channelHandle: string;
    };
    query?: never;
    url: '/api/v1/video-channels/{channelHandle}/avatar';
};

export type DeleteApiV1VideoChannelsByChannelHandleAvatarResponses = {
    /**
     * successful operation
     */
    204: void;
};

export type DeleteApiV1VideoChannelsByChannelHandleAvatarResponse = DeleteApiV1VideoChannelsByChannelHandleAvatarResponses[keyof DeleteApiV1VideoChannelsByChannelHandleAvatarResponses];

export type PostApiV1VideoChannelsByChannelHandleBannerPickData = {
    body?: {
        /**
         * The file to upload.
         */
        bannerfile?: Blob | File;
    };
    path: {
        /**
         * The video channel handle
         */
        channelHandle: string;
    };
    query?: never;
    url: '/api/v1/video-channels/{channelHandle}/banner/pick';
};

export type PostApiV1VideoChannelsByChannelHandleBannerPickErrors = {
    /**
     * image file too large
     */
    413: unknown;
};

export type PostApiV1VideoChannelsByChannelHandleBannerPickResponses = {
    /**
     * successful operation
     */
    200: {
        banners?: Array<ActorImage>;
    };
};

export type PostApiV1VideoChannelsByChannelHandleBannerPickResponse = PostApiV1VideoChannelsByChannelHandleBannerPickResponses[keyof PostApiV1VideoChannelsByChannelHandleBannerPickResponses];

export type DeleteApiV1VideoChannelsByChannelHandleBannerData = {
    body?: never;
    path: {
        /**
         * The video channel handle
         */
        channelHandle: string;
    };
    query?: never;
    url: '/api/v1/video-channels/{channelHandle}/banner';
};

export type DeleteApiV1VideoChannelsByChannelHandleBannerResponses = {
    /**
     * successful operation
     */
    204: void;
};

export type DeleteApiV1VideoChannelsByChannelHandleBannerResponse = DeleteApiV1VideoChannelsByChannelHandleBannerResponses[keyof DeleteApiV1VideoChannelsByChannelHandleBannerResponses];

export type PostApiV1VideoChannelsByChannelHandleImportVideosData = {
    body?: ImportVideosInChannelCreate;
    path: {
        /**
         * The video channel handle
         */
        channelHandle: string;
    };
    query?: never;
    url: '/api/v1/video-channels/{channelHandle}/import-videos';
};

export type PostApiV1VideoChannelsByChannelHandleImportVideosResponses = {
    /**
     * successful operation
     */
    204: void;
};

export type PostApiV1VideoChannelsByChannelHandleImportVideosResponse = PostApiV1VideoChannelsByChannelHandleImportVideosResponses[keyof PostApiV1VideoChannelsByChannelHandleImportVideosResponses];

export type AddVideoChannelSyncData = {
    body?: VideoChannelSyncCreate;
    path?: never;
    query?: never;
    url: '/api/v1/video-channel-syncs';
};

export type AddVideoChannelSyncResponses = {
    /**
     * successful operation
     */
    200: {
        videoChannelSync?: VideoChannelSync;
    };
};

export type AddVideoChannelSyncResponse = AddVideoChannelSyncResponses[keyof AddVideoChannelSyncResponses];

export type DelVideoChannelSyncData = {
    body?: never;
    path: {
        /**
         * Channel Sync id
         */
        channelSyncId: Id;
    };
    query?: never;
    url: '/api/v1/video-channel-syncs/{channelSyncId}';
};

export type DelVideoChannelSyncResponses = {
    /**
     * successful operation
     */
    204: void;
};

export type DelVideoChannelSyncResponse = DelVideoChannelSyncResponses[keyof DelVideoChannelSyncResponses];

export type TriggerVideoChannelSyncData = {
    body?: never;
    path: {
        /**
         * Channel Sync id
         */
        channelSyncId: Id;
    };
    query?: never;
    url: '/api/v1/video-channel-syncs/{channelSyncId}/sync';
};

export type TriggerVideoChannelSyncResponses = {
    /**
     * successful operation
     */
    204: void;
};

export type TriggerVideoChannelSyncResponse = TriggerVideoChannelSyncResponses[keyof TriggerVideoChannelSyncResponses];

export type GetVideoPlayerSettingsData = {
    body?: never;
    path: {
        /**
         * The object id, uuid or short uuid
         */
        id: Id | UuiDv4 | ShortUuid;
    };
    query?: {
        /**
         * Return raw settings without merging channel defaults
         */
        raw?: boolean;
    };
    url: '/api/v1/player-settings/videos/{id}';
};

export type GetVideoPlayerSettingsErrors = {
    /**
     * video not found
     */
    404: unknown;
};

export type GetVideoPlayerSettingsResponses = {
    /**
     * successful operation
     */
    200: PlayerVideoSettings;
};

export type GetVideoPlayerSettingsResponse = GetVideoPlayerSettingsResponses[keyof GetVideoPlayerSettingsResponses];

export type UpdateVideoPlayerSettingsData = {
    body?: PlayerVideoSettingsUpdate;
    path: {
        /**
         * The object id, uuid or short uuid
         */
        id: Id | UuiDv4 | ShortUuid;
    };
    query?: never;
    url: '/api/v1/player-settings/videos/{id}';
};

export type UpdateVideoPlayerSettingsErrors = {
    /**
     * video not found
     */
    404: unknown;
};

export type UpdateVideoPlayerSettingsResponses = {
    /**
     * successful operation
     */
    200: PlayerVideoSettings;
};

export type UpdateVideoPlayerSettingsResponse = UpdateVideoPlayerSettingsResponses[keyof UpdateVideoPlayerSettingsResponses];

export type GetChannelPlayerSettingsData = {
    body?: never;
    path: {
        /**
         * The video channel handle
         */
        channelHandle: string;
    };
    query?: {
        /**
         * Return raw settings without applying instance defaults
         */
        raw?: boolean;
    };
    url: '/api/v1/player-settings/video-channels/{channelHandle}';
};

export type GetChannelPlayerSettingsErrors = {
    /**
     * video channel not found
     */
    404: unknown;
};

export type GetChannelPlayerSettingsResponses = {
    /**
     * successful operation
     */
    200: PlayerChannelSettings;
};

export type GetChannelPlayerSettingsResponse = GetChannelPlayerSettingsResponses[keyof GetChannelPlayerSettingsResponses];

export type UpdateChannelPlayerSettingsData = {
    body?: PlayerChannelSettingsUpdate;
    path: {
        /**
         * The video channel handle
         */
        channelHandle: string;
    };
    query?: never;
    url: '/api/v1/player-settings/video-channels/{channelHandle}';
};

export type UpdateChannelPlayerSettingsErrors = {
    /**
     * video channel not found
     */
    404: unknown;
};

export type UpdateChannelPlayerSettingsResponses = {
    /**
     * successful operation
     */
    200: PlayerChannelSettings;
};

export type UpdateChannelPlayerSettingsResponse = UpdateChannelPlayerSettingsResponses[keyof UpdateChannelPlayerSettingsResponses];

export type GetPlaylistPrivacyPoliciesData = {
    body?: never;
    path?: never;
    query?: never;
    url: '/api/v1/video-playlists/privacies';
};

export type GetPlaylistPrivacyPoliciesResponses = {
    /**
     * successful operation
     */
    200: Array<string>;
};

export type GetPlaylistPrivacyPoliciesResponse = GetPlaylistPrivacyPoliciesResponses[keyof GetPlaylistPrivacyPoliciesResponses];

export type GetPlaylistsData = {
    body?: never;
    path?: never;
    query?: {
        /**
         * Offset used to paginate results
         */
        start?: number;
        /**
         * Number of items to return
         */
        count?: number;
        /**
         * Sort column
         */
        sort?: string;
        playlistType?: VideoPlaylistTypeSet;
    };
    url: '/api/v1/video-playlists';
};

export type GetPlaylistsResponses = {
    /**
     * successful operation
     */
    200: {
        total?: number;
        data?: Array<VideoPlaylist>;
    };
};

export type GetPlaylistsResponse = GetPlaylistsResponses[keyof GetPlaylistsResponses];

export type AddPlaylistData = {
    body?: {
        /**
         * Video playlist display name
         */
        displayName: string;
        /**
         * Video playlist thumbnail file
         */
        thumbnailfile?: Blob | File;
        privacy?: VideoPlaylistPrivacySet;
        /**
         * Video playlist description
         */
        description?: string;
        /**
         * Video channel in which the playlist will be published
         */
        videoChannelId?: Id;
    };
    path?: never;
    query?: never;
    url: '/api/v1/video-playlists';
};

export type AddPlaylistResponses = {
    /**
     * successful operation
     */
    200: {
        videoPlaylist?: {
            id?: Id;
            uuid?: UuiDv4;
            shortUUID?: 18;
        };
    };
};

export type AddPlaylistResponse = AddPlaylistResponses[keyof AddPlaylistResponses];

export type DeleteApiV1VideoPlaylistsByPlaylistIdData = {
    body?: never;
    path: {
        /**
         * Playlist id
         */
        playlistId: Id;
    };
    query?: never;
    url: '/api/v1/video-playlists/{playlistId}';
};

export type DeleteApiV1VideoPlaylistsByPlaylistIdResponses = {
    /**
     * successful operation
     */
    204: void;
};

export type DeleteApiV1VideoPlaylistsByPlaylistIdResponse = DeleteApiV1VideoPlaylistsByPlaylistIdResponses[keyof DeleteApiV1VideoPlaylistsByPlaylistIdResponses];

export type GetApiV1VideoPlaylistsByPlaylistIdData = {
    body?: never;
    path: {
        /**
         * Playlist id
         */
        playlistId: Id;
    };
    query?: never;
    url: '/api/v1/video-playlists/{playlistId}';
};

export type GetApiV1VideoPlaylistsByPlaylistIdResponses = {
    /**
     * successful operation
     */
    200: VideoPlaylist;
};

export type GetApiV1VideoPlaylistsByPlaylistIdResponse = GetApiV1VideoPlaylistsByPlaylistIdResponses[keyof GetApiV1VideoPlaylistsByPlaylistIdResponses];

export type PutApiV1VideoPlaylistsByPlaylistIdData = {
    body?: {
        /**
         * Video playlist display name
         */
        displayName?: string;
        /**
         * Video playlist thumbnail file
         */
        thumbnailfile?: Blob | File;
        privacy?: VideoPlaylistPrivacySet;
        /**
         * Video playlist description
         */
        description?: string;
        /**
         * Video channel in which the playlist will be published
         */
        videoChannelId?: Id;
    };
    path: {
        /**
         * Playlist id
         */
        playlistId: Id;
    };
    query?: never;
    url: '/api/v1/video-playlists/{playlistId}';
};

export type PutApiV1VideoPlaylistsByPlaylistIdResponses = {
    /**
     * successful operation
     */
    204: void;
};

export type PutApiV1VideoPlaylistsByPlaylistIdResponse = PutApiV1VideoPlaylistsByPlaylistIdResponses[keyof PutApiV1VideoPlaylistsByPlaylistIdResponses];

export type GetVideoPlaylistVideosData = {
    body?: never;
    path: {
        /**
         * Playlist id
         */
        playlistId: Id;
    };
    query?: {
        /**
         * Offset used to paginate results
         */
        start?: number;
        /**
         * Number of items to return
         */
        count?: number;
    };
    url: '/api/v1/video-playlists/{playlistId}/videos';
};

export type GetVideoPlaylistVideosResponses = {
    /**
     * successful operation
     */
    200: {
        total?: number;
        data?: Array<{
            /**
             * object id for the video
             */
            id?: Id;
            position?: number;
            startTimestamp?: number | null;
            stopTimestamp?: number | null;
            video?: Video;
        }>;
    };
};

export type GetVideoPlaylistVideosResponse = GetVideoPlaylistVideosResponses[keyof GetVideoPlaylistVideosResponses];

export type AddVideoPlaylistVideoData = {
    body?: {
        /**
         * Video to add in the playlist
         */
        videoId: 2 | 8;
        /**
         * Start the video at this specific timestamp
         */
        startTimestamp?: number;
        /**
         * Stop the video at this specific timestamp
         */
        stopTimestamp?: number;
    };
    path: {
        /**
         * Playlist id
         */
        playlistId: Id;
    };
    query?: never;
    url: '/api/v1/video-playlists/{playlistId}/videos';
};

export type AddVideoPlaylistVideoResponses = {
    /**
     * successful operation
     */
    200: {
        videoPlaylistElement?: {
            id?: number;
        };
    };
};

export type AddVideoPlaylistVideoResponse = AddVideoPlaylistVideoResponses[keyof AddVideoPlaylistVideoResponses];

export type ReorderVideoPlaylistData = {
    body?: {
        /**
         * Start position of the element to reorder
         */
        startPosition: number;
        /**
         * New position for the block to reorder, to add the block before the first element
         */
        insertAfterPosition: number;
        /**
         * How many element from `startPosition` to reorder
         */
        reorderLength?: number;
    };
    path: {
        /**
         * Playlist id
         */
        playlistId: Id;
    };
    query?: never;
    url: '/api/v1/video-playlists/{playlistId}/videos/reorder';
};

export type ReorderVideoPlaylistResponses = {
    /**
     * successful operation
     */
    204: void;
};

export type ReorderVideoPlaylistResponse = ReorderVideoPlaylistResponses[keyof ReorderVideoPlaylistResponses];

export type DelVideoPlaylistVideoData = {
    body?: never;
    path: {
        /**
         * Playlist id
         */
        playlistId: Id;
        /**
         * Playlist element id
         */
        playlistElementId: Id;
    };
    query?: never;
    url: '/api/v1/video-playlists/{playlistId}/videos/{playlistElementId}';
};

export type DelVideoPlaylistVideoResponses = {
    /**
     * successful operation
     */
    204: void;
};

export type DelVideoPlaylistVideoResponse = DelVideoPlaylistVideoResponses[keyof DelVideoPlaylistVideoResponses];

export type PutVideoPlaylistVideoData = {
    body?: {
        /**
         * Start the video at this specific timestamp
         */
        startTimestamp?: number;
        /**
         * Stop the video at this specific timestamp
         */
        stopTimestamp?: number;
    };
    path: {
        /**
         * Playlist id
         */
        playlistId: Id;
        /**
         * Playlist element id
         */
        playlistElementId: Id;
    };
    query?: never;
    url: '/api/v1/video-playlists/{playlistId}/videos/{playlistElementId}';
};

export type PutVideoPlaylistVideoResponses = {
    /**
     * successful operation
     */
    204: void;
};

export type PutVideoPlaylistVideoResponse = PutVideoPlaylistVideoResponses[keyof PutVideoPlaylistVideoResponses];

export type GetApiV1UsersMeVideoPlaylistsVideosExistData = {
    body?: never;
    path?: never;
    query: {
        /**
         * The video ids to check
         */
        videoIds: Array<8>;
    };
    url: '/api/v1/users/me/video-playlists/videos-exist';
};

export type GetApiV1UsersMeVideoPlaylistsVideosExistResponses = {
    /**
     * successful operation
     */
    200: {
        videoId?: Array<{
            playlistElementId?: number;
            playlistId?: number;
            startTimestamp?: number | null;
            stopTimestamp?: number | null;
        }>;
    };
};

export type GetApiV1UsersMeVideoPlaylistsVideosExistResponse = GetApiV1UsersMeVideoPlaylistsVideosExistResponses[keyof GetApiV1UsersMeVideoPlaylistsVideosExistResponses];

export type GetApiV1AccountsByNameVideoPlaylistsData = {
    body?: never;
    path: {
        /**
         * The username or handle of the account
         */
        name: string;
    };
    query?: {
        /**
         * Offset used to paginate results
         */
        start?: number;
        /**
         * Number of items to return
         */
        count?: number;
        /**
         * Sort column
         */
        sort?: string;
        /**
         * Plain text search, applied to various parts of the model depending on endpoint
         */
        search?: string;
        playlistType?: VideoPlaylistTypeSet;
    };
    url: '/api/v1/accounts/{name}/video-playlists';
};

export type GetApiV1AccountsByNameVideoPlaylistsResponses = {
    /**
     * successful operation
     */
    200: {
        total?: number;
        data?: Array<VideoPlaylist>;
    };
};

export type GetApiV1AccountsByNameVideoPlaylistsResponse = GetApiV1AccountsByNameVideoPlaylistsResponses[keyof GetApiV1AccountsByNameVideoPlaylistsResponses];

export type GetApiV1AccountsByNameVideoChannelsData = {
    body?: never;
    path: {
        /**
         * The username or handle of the account
         */
        name: string;
    };
    query?: {
        /**
         * include daily view statistics for the last 30 days and total views (only if authentified as the account user)
         */
        withStats?: boolean;
        /**
         * Offset used to paginate results
         */
        start?: number;
        /**
         * Number of items to return
         */
        count?: number;
        /**
         * Sort column
         */
        sort?: string;
    };
    url: '/api/v1/accounts/{name}/video-channels';
};

export type GetApiV1AccountsByNameVideoChannelsResponses = {
    /**
     * successful operation
     */
    200: VideoChannelList;
};

export type GetApiV1AccountsByNameVideoChannelsResponse = GetApiV1AccountsByNameVideoChannelsResponses[keyof GetApiV1AccountsByNameVideoChannelsResponses];

export type GetApiV1AccountsByNameVideoChannelSyncsData = {
    body?: never;
    path: {
        /**
         * The username or handle of the account
         */
        name: string;
    };
    query?: {
        /**
         * Offset used to paginate results
         */
        start?: number;
        /**
         * Number of items to return
         */
        count?: number;
        /**
         * Sort column
         */
        sort?: string;
    };
    url: '/api/v1/accounts/{name}/video-channel-syncs';
};

export type GetApiV1AccountsByNameVideoChannelSyncsResponses = {
    /**
     * successful operation
     */
    200: VideoChannelSyncList;
};

export type GetApiV1AccountsByNameVideoChannelSyncsResponse = GetApiV1AccountsByNameVideoChannelSyncsResponses[keyof GetApiV1AccountsByNameVideoChannelSyncsResponses];

export type GetApiV1AccountsByNameRatingsData = {
    body?: never;
    path: {
        /**
         * The username or handle of the account
         */
        name: string;
    };
    query?: {
        /**
         * Offset used to paginate results
         */
        start?: number;
        /**
         * Number of items to return
         */
        count?: number;
        /**
         * Sort column
         */
        sort?: string;
        /**
         * Optionally filter which ratings to retrieve
         */
        rating?: 'like' | 'dislike';
    };
    url: '/api/v1/accounts/{name}/ratings';
};

export type GetApiV1AccountsByNameRatingsResponses = {
    /**
     * successful operation
     */
    200: Array<VideoRating>;
};

export type GetApiV1AccountsByNameRatingsResponse = GetApiV1AccountsByNameRatingsResponses[keyof GetApiV1AccountsByNameRatingsResponses];

export type GetApiV1VideosByIdCommentThreadsData = {
    body?: never;
    headers?: {
        /**
         * Required on password protected video
         */
        'x-peertube-video-password'?: string;
    };
    path: {
        /**
         * The object id, uuid or short uuid
         */
        id: Id | UuiDv4 | ShortUuid;
    };
    query?: {
        /**
         * Offset used to paginate results
         */
        start?: number;
        /**
         * Number of items to return
         */
        count?: number;
        /**
         * Sort comments by criteria
         */
        sort?: '-createdAt' | '-totalReplies';
    };
    url: '/api/v1/videos/{id}/comment-threads';
};

export type GetApiV1VideosByIdCommentThreadsResponses = {
    /**
     * successful operation
     */
    200: CommentThreadResponse;
};

export type GetApiV1VideosByIdCommentThreadsResponse = GetApiV1VideosByIdCommentThreadsResponses[keyof GetApiV1VideosByIdCommentThreadsResponses];

export type PostApiV1VideosByIdCommentThreadsData = {
    body?: {
        text: 10;
    };
    path: {
        /**
         * The object id, uuid or short uuid
         */
        id: Id | UuiDv4 | ShortUuid;
    };
    query?: never;
    url: '/api/v1/videos/{id}/comment-threads';
};

export type PostApiV1VideosByIdCommentThreadsErrors = {
    /**
     * video does not exist
     */
    404: unknown;
};

export type PostApiV1VideosByIdCommentThreadsResponses = {
    /**
     * successful operation
     */
    200: CommentThreadPostResponse;
};

export type PostApiV1VideosByIdCommentThreadsResponse = PostApiV1VideosByIdCommentThreadsResponses[keyof PostApiV1VideosByIdCommentThreadsResponses];

export type GetApiV1VideosByIdCommentThreadsByThreadIdData = {
    body?: never;
    headers?: {
        /**
         * Required on password protected video
         */
        'x-peertube-video-password'?: string;
    };
    path: {
        /**
         * The object id, uuid or short uuid
         */
        id: Id | UuiDv4 | ShortUuid;
        /**
         * The thread id (root comment id)
         */
        threadId: number;
    };
    query?: never;
    url: '/api/v1/videos/{id}/comment-threads/{threadId}';
};

export type GetApiV1VideosByIdCommentThreadsByThreadIdResponses = {
    /**
     * successful operation
     */
    200: VideoCommentThreadTree;
};

export type GetApiV1VideosByIdCommentThreadsByThreadIdResponse = GetApiV1VideosByIdCommentThreadsByThreadIdResponses[keyof GetApiV1VideosByIdCommentThreadsByThreadIdResponses];

export type GetApiV1VideosCommentsData = {
    body?: never;
    path?: never;
    query?: {
        /**
         * Plain text search, applied to various parts of the model depending on endpoint
         */
        search?: string;
        /**
         * Filter comments by searching on the account
         */
        searchAccount?: string;
        /**
         * Filter comments by searching on the video
         */
        searchVideo?: string;
        /**
         * Limit results on this specific video
         */
        videoId?: number;
        /**
         * Limit results on this specific video channel
         */
        videoChannelId?: number;
        /**
         * **PeerTube >= 6.2** filter on comments that contain one of these automatic tags
         */
        autoTagOneOf?: string | Array<string>;
        /**
         * **PeerTube >= 4.0** Display only local or remote objects
         */
        isLocal?: boolean;
        /**
         * Display only objects of local or remote videos
         */
        onLocalVideo?: boolean;
    };
    url: '/api/v1/videos/comments';
};

export type GetApiV1VideosCommentsResponses = {
    /**
     * successful operation
     */
    200: {
        total?: number;
        data?: Array<VideoCommentForOwnerOrAdmin>;
    };
};

export type GetApiV1VideosCommentsResponse = GetApiV1VideosCommentsResponses[keyof GetApiV1VideosCommentsResponses];

export type DeleteApiV1VideosByIdCommentsByCommentIdData = {
    body?: never;
    path: {
        /**
         * The object id, uuid or short uuid
         */
        id: Id | UuiDv4 | ShortUuid;
        /**
         * The comment id
         */
        commentId: Id;
    };
    query?: never;
    url: '/api/v1/videos/{id}/comments/{commentId}';
};

export type DeleteApiV1VideosByIdCommentsByCommentIdErrors = {
    /**
     * cannot remove comment of another user
     */
    403: unknown;
    /**
     * comment or video does not exist
     */
    404: unknown;
    /**
     * comment is already deleted
     */
    409: unknown;
};

export type DeleteApiV1VideosByIdCommentsByCommentIdResponses = {
    /**
     * successful operation
     */
    204: void;
};

export type DeleteApiV1VideosByIdCommentsByCommentIdResponse = DeleteApiV1VideosByIdCommentsByCommentIdResponses[keyof DeleteApiV1VideosByIdCommentsByCommentIdResponses];

export type PostApiV1VideosByIdCommentsByCommentIdData = {
    body?: {
        text: 10;
    };
    headers?: {
        /**
         * Required on password protected video
         */
        'x-peertube-video-password'?: string;
    };
    path: {
        /**
         * The object id, uuid or short uuid
         */
        id: Id | UuiDv4 | ShortUuid;
        /**
         * The comment id
         */
        commentId: Id;
    };
    query?: never;
    url: '/api/v1/videos/{id}/comments/{commentId}';
};

export type PostApiV1VideosByIdCommentsByCommentIdErrors = {
    /**
     * thread or video does not exist
     */
    404: unknown;
};

export type PostApiV1VideosByIdCommentsByCommentIdResponses = {
    /**
     * successful operation
     */
    200: CommentThreadPostResponse;
};

export type PostApiV1VideosByIdCommentsByCommentIdResponse = PostApiV1VideosByIdCommentsByCommentIdResponses[keyof PostApiV1VideosByIdCommentsByCommentIdResponses];

export type PostApiV1VideosByIdCommentsByCommentIdApproveData = {
    body?: never;
    path: {
        /**
         * The object id, uuid or short uuid
         */
        id: Id | UuiDv4 | ShortUuid;
        /**
         * The comment id
         */
        commentId: Id;
    };
    query?: never;
    url: '/api/v1/videos/{id}/comments/{commentId}/approve';
};

export type PostApiV1VideosByIdCommentsByCommentIdApproveResponses = {
    /**
     * successful operation
     */
    204: void;
};

export type PostApiV1VideosByIdCommentsByCommentIdApproveResponse = PostApiV1VideosByIdCommentsByCommentIdApproveResponses[keyof PostApiV1VideosByIdCommentsByCommentIdApproveResponses];

export type PutApiV1VideosByIdRateData = {
    body?: {
        rating: 'like' | 'dislike';
    };
    headers?: {
        /**
         * Required on password protected video
         */
        'x-peertube-video-password'?: string;
    };
    path: {
        /**
         * The object id, uuid or short uuid
         */
        id: Id | UuiDv4 | ShortUuid;
    };
    query?: never;
    url: '/api/v1/videos/{id}/rate';
};

export type PutApiV1VideosByIdRateErrors = {
    /**
     * video does not exist
     */
    404: unknown;
};

export type PutApiV1VideosByIdRateResponses = {
    /**
     * successful operation
     */
    204: void;
};

export type PutApiV1VideosByIdRateResponse = PutApiV1VideosByIdRateResponses[keyof PutApiV1VideosByIdRateResponses];

export type DelVideoHlsData = {
    body?: never;
    path: {
        /**
         * The object id, uuid or short uuid
         */
        id: Id | UuiDv4 | ShortUuid;
    };
    query?: never;
    url: '/api/v1/videos/{id}/hls';
};

export type DelVideoHlsErrors = {
    /**
     * video does not exist
     */
    404: unknown;
};

export type DelVideoHlsResponses = {
    /**
     * successful operation
     */
    204: void;
};

export type DelVideoHlsResponse = DelVideoHlsResponses[keyof DelVideoHlsResponses];

export type DelVideoWebVideosData = {
    body?: never;
    path: {
        /**
         * The object id, uuid or short uuid
         */
        id: Id | UuiDv4 | ShortUuid;
    };
    query?: never;
    url: '/api/v1/videos/{id}/web-videos';
};

export type DelVideoWebVideosErrors = {
    /**
     * video does not exist
     */
    404: unknown;
};

export type DelVideoWebVideosResponses = {
    /**
     * successful operation
     */
    204: void;
};

export type DelVideoWebVideosResponse = DelVideoWebVideosResponses[keyof DelVideoWebVideosResponses];

export type CreateVideoTranscodingData = {
    body?: {
        transcodingType: 'hls' | 'web-video';
        /**
         * If the video is stuck in transcoding state, do it anyway
         */
        forceTranscoding?: boolean;
    };
    path: {
        /**
         * The object id, uuid or short uuid
         */
        id: Id | UuiDv4 | ShortUuid;
    };
    query?: never;
    url: '/api/v1/videos/{id}/transcoding';
};

export type CreateVideoTranscodingErrors = {
    /**
     * video does not exist
     */
    404: unknown;
};

export type CreateVideoTranscodingResponses = {
    /**
     * successful operation
     */
    204: void;
};

export type CreateVideoTranscodingResponse = CreateVideoTranscodingResponses[keyof CreateVideoTranscodingResponses];

export type SearchVideosData = {
    body?: never;
    path?: never;
    query: {
        /**
         * String to search. If the user can make a remote URI search, and the string is an URI then the PeerTube instance will fetch the remote object and add it to its database. Then, you can use the REST API to fetch the complete video information and interact with it.
         *
         */
        search: string;
        /**
         * Find elements with specific UUIDs
         */
        uuids?: unknown;
        /**
         * If the administrator enabled search index support, you can override the default search target.
         *
         * **Warning**: If you choose to make an index search, PeerTube will get results from a third party service. It means the instance may not yet know the objects you fetched. If you want to load video/channel information:
         * * If the current user has the ability to make a remote URI search (this information is available in the config endpoint),
         * then reuse the search API to make a search using the object URI so PeerTube instance fetches the remote object and fill its database.
         * After that, you can use the classic REST API endpoints to fetch the complete object or interact with it
         * * If the current user doesn't have the ability to make a remote URI search, then redirect the user on the origin instance or fetch
         * the data from the origin instance API
         *
         */
        searchTarget?: 'local' | 'search-index';
        /**
         * Offset used to paginate results
         */
        start?: number;
        /**
         * Number of items to return
         */
        count?: number;
        /**
         * if you don't need the `total` in the response
         */
        skipCount?: 'true' | 'false';
        /**
         * Sort videos by criteria (prefixing with `-` means `DESC` order):
         * * `hot` - Adaptation of Reddit "hot" algorithm taking into account video views, likes, dislikes and comments and publication date
         * * `best` - Same than `hot`, but also takes into account user video history
         * * `trending` - Sort videos by recent views ("recent" is defined by the admin)
         * * `views` - Sort videos using their `views` counter
         * * `publishedAt` - Sort by video publication date (when it became publicly available)
         *
         */
        sort?: 'name' | '-duration' | '-createdAt' | '-publishedAt' | '-views' | '-likes' | '-comments' | '-trending' | '-hot' | '-best';
        /**
         * whether to include nsfw videos, if any
         */
        nsfw?: 'true' | 'false';
        nsfwFlagsIncluded?: NsfwFlag;
        nsfwFlagsExcluded?: NsfwFlag;
        /**
         * whether or not the video is a live
         */
        isLive?: boolean;
        /**
         * whether or not include live that are scheduled for later
         */
        includeScheduledLive?: boolean;
        /**
         * category id of the video (see [/videos/categories](#operation/getCategories))
         */
        categoryOneOf?: VideoCategorySet | Array<VideoCategorySet>;
        /**
         * licence id of the video (see [/videos/licences](#operation/getLicences))
         */
        licenceOneOf?: VideoLicenceSet | Array<VideoLicenceSet>;
        /**
         * language id of the video (see [/videos/languages](#operation/getLanguages)). Use `_unknown` to filter on videos that don't have a video language
         */
        languageOneOf?: VideoLanguageSet | Array<VideoLanguageSet>;
        /**
         * tag(s) of the video
         */
        tagsOneOf?: string | Array<string>;
        /**
         * tag(s) of the video, where all should be present in the video
         */
        tagsAllOf?: string | Array<string>;
        /**
         * **PeerTube >= 4.0** Display only local or remote objects
         */
        isLocal?: boolean;
        /**
         * **Only administrators and moderators can use this parameter**
         *
         * Include additional videos in results (can be combined using bitwise or operator)
         * - `0` NONE
         * - `1` NOT_PUBLISHED_STATE
         * - `2` BLACKLISTED
         * - `4` BLOCKED_OWNER
         * - `8` FILES
         * - `16` CAPTIONS
         * - `32` VIDEO SOURCE
         *
         */
        include?: 0 | 1 | 2 | 4 | 8 | 16 | 32;
        /**
         * **PeerTube >= 4.0** Display only videos that have HLS files
         */
        hasHLSFiles?: boolean;
        /**
         * **PeerTube >= 6.0** Display only videos that have Web Video files
         */
        hasWebVideoFiles?: boolean;
        /**
         * Find elements owned by this host
         */
        host?: string;
        /**
         * **PeerTube >= 6.2** **Admins and moderators only** filter on videos that contain one of these automatic tags
         */
        autoTagOneOf?: string | Array<string>;
        /**
         * **PeerTube >= 4.0** Display only videos in this specific privacy/privacies
         */
        privacyOneOf?: VideoPrivacySet;
        /**
         * Whether or not to exclude videos that are in the user's video history
         */
        excludeAlreadyWatched?: boolean;
        /**
         * Get videos that are published after this date
         */
        startDate?: string;
        /**
         * Get videos that are published before this date
         */
        endDate?: string;
        /**
         * Get videos that are originally published after this date
         */
        originallyPublishedStartDate?: string;
        /**
         * Get videos that are originally published before this date
         */
        originallyPublishedEndDate?: string;
        /**
         * Get videos that have this minimum duration
         */
        durationMin?: number;
        /**
         * Get videos that have this maximum duration
         */
        durationMax?: number;
    };
    url: '/api/v1/search/videos';
};

export type SearchVideosErrors = {
    /**
     * search index unavailable
     */
    500: unknown;
};

export type SearchVideosResponses = {
    /**
     * successful operation
     */
    200: VideoListResponse;
};

export type SearchVideosResponse = SearchVideosResponses[keyof SearchVideosResponses];

export type SearchChannelsData = {
    body?: never;
    path?: never;
    query: {
        /**
         * String to search. If the user can make a remote URI search, and the string is an URI then the PeerTube instance will fetch the remote object and add it to its database. Then, you can use the REST API to fetch the complete channel information and interact with it.
         *
         */
        search: string;
        /**
         * Offset used to paginate results
         */
        start?: number;
        /**
         * Number of items to return
         */
        count?: number;
        /**
         * If the administrator enabled search index support, you can override the default search target.
         *
         * **Warning**: If you choose to make an index search, PeerTube will get results from a third party service. It means the instance may not yet know the objects you fetched. If you want to load video/channel information:
         * * If the current user has the ability to make a remote URI search (this information is available in the config endpoint),
         * then reuse the search API to make a search using the object URI so PeerTube instance fetches the remote object and fill its database.
         * After that, you can use the classic REST API endpoints to fetch the complete object or interact with it
         * * If the current user doesn't have the ability to make a remote URI search, then redirect the user on the origin instance or fetch
         * the data from the origin instance API
         *
         */
        searchTarget?: 'local' | 'search-index';
        /**
         * Sort column
         */
        sort?: string;
        /**
         * Find elements owned by this host
         */
        host?: string;
        /**
         * Find elements with these handles
         */
        handles?: unknown;
    };
    url: '/api/v1/search/video-channels';
};

export type SearchChannelsErrors = {
    /**
     * search index unavailable
     */
    500: unknown;
};

export type SearchChannelsResponses = {
    /**
     * successful operation
     */
    200: VideoChannelList;
};

export type SearchChannelsResponse = SearchChannelsResponses[keyof SearchChannelsResponses];

export type SearchPlaylistsData = {
    body?: never;
    path?: never;
    query: {
        /**
         * String to search. If the user can make a remote URI search, and the string is an URI then the PeerTube instance will fetch the remote object and add it to its database. Then, you can use the REST API to fetch the complete playlist information and interact with it.
         *
         */
        search: string;
        /**
         * Offset used to paginate results
         */
        start?: number;
        /**
         * Number of items to return
         */
        count?: number;
        /**
         * If the administrator enabled search index support, you can override the default search target.
         *
         * **Warning**: If you choose to make an index search, PeerTube will get results from a third party service. It means the instance may not yet know the objects you fetched. If you want to load video/channel information:
         * * If the current user has the ability to make a remote URI search (this information is available in the config endpoint),
         * then reuse the search API to make a search using the object URI so PeerTube instance fetches the remote object and fill its database.
         * After that, you can use the classic REST API endpoints to fetch the complete object or interact with it
         * * If the current user doesn't have the ability to make a remote URI search, then redirect the user on the origin instance or fetch
         * the data from the origin instance API
         *
         */
        searchTarget?: 'local' | 'search-index';
        /**
         * Sort column
         */
        sort?: string;
        /**
         * Find elements owned by this host
         */
        host?: string;
        /**
         * Find elements with specific UUIDs
         */
        uuids?: unknown;
    };
    url: '/api/v1/search/video-playlists';
};

export type SearchPlaylistsErrors = {
    /**
     * search index unavailable
     */
    500: unknown;
};

export type SearchPlaylistsResponses = {
    /**
     * successful operation
     */
    200: {
        total?: number;
        data?: Array<VideoPlaylist>;
    };
};

export type SearchPlaylistsResponse = SearchPlaylistsResponses[keyof SearchPlaylistsResponses];

export type GetApiV1BlocklistStatusData = {
    body?: never;
    path?: never;
    query?: {
        /**
         * Check if these accounts are blocked
         */
        accounts?: Array<string>;
        /**
         * Check if these hosts are blocked
         */
        hosts?: Array<string>;
    };
    url: '/api/v1/blocklist/status';
};

export type GetApiV1BlocklistStatusResponses = {
    /**
     * successful operation
     */
    200: BlockStatus;
};

export type GetApiV1BlocklistStatusResponse = GetApiV1BlocklistStatusResponses[keyof GetApiV1BlocklistStatusResponses];

export type GetApiV1ServerBlocklistAccountsData = {
    body?: never;
    path?: never;
    query?: {
        /**
         * Offset used to paginate results
         */
        start?: number;
        /**
         * Number of items to return
         */
        count?: number;
        /**
         * Sort column
         */
        sort?: string;
    };
    url: '/api/v1/server/blocklist/accounts';
};

export type GetApiV1ServerBlocklistAccountsResponses = {
    /**
     * successful operation
     */
    200: unknown;
};

export type PostApiV1ServerBlocklistAccountsData = {
    body?: {
        /**
         * account to block, in the form `username@domain`
         */
        accountName: string;
    };
    path?: never;
    query?: never;
    url: '/api/v1/server/blocklist/accounts';
};

export type PostApiV1ServerBlocklistAccountsErrors = {
    /**
     * self-blocking forbidden
     */
    409: unknown;
};

export type PostApiV1ServerBlocklistAccountsResponses = {
    /**
     * successful operation
     */
    200: unknown;
};

export type DeleteApiV1ServerBlocklistAccountsByAccountNameData = {
    body?: never;
    path: {
        /**
         * account to unblock, in the form `username@domain`
         */
        accountName: string;
    };
    query?: never;
    url: '/api/v1/server/blocklist/accounts/{accountName}';
};

export type DeleteApiV1ServerBlocklistAccountsByAccountNameErrors = {
    /**
     * account or account block does not exist
     */
    404: unknown;
};

export type DeleteApiV1ServerBlocklistAccountsByAccountNameResponses = {
    /**
     * successful operation
     */
    201: unknown;
};

export type GetApiV1ServerBlocklistServersData = {
    body?: never;
    path?: never;
    query?: {
        /**
         * Offset used to paginate results
         */
        start?: number;
        /**
         * Number of items to return
         */
        count?: number;
        /**
         * Sort column
         */
        sort?: string;
    };
    url: '/api/v1/server/blocklist/servers';
};

export type GetApiV1ServerBlocklistServersResponses = {
    /**
     * successful operation
     */
    200: unknown;
};

export type PostApiV1ServerBlocklistServersData = {
    body?: {
        /**
         * server domain to block
         */
        host: string;
    };
    path?: never;
    query?: never;
    url: '/api/v1/server/blocklist/servers';
};

export type PostApiV1ServerBlocklistServersErrors = {
    /**
     * self-blocking forbidden
     */
    409: unknown;
};

export type PostApiV1ServerBlocklistServersResponses = {
    /**
     * successful operation
     */
    204: void;
};

export type PostApiV1ServerBlocklistServersResponse = PostApiV1ServerBlocklistServersResponses[keyof PostApiV1ServerBlocklistServersResponses];

export type DeleteApiV1ServerBlocklistServersByHostData = {
    body?: never;
    path: {
        /**
         * server domain to unblock
         */
        host: string;
    };
    query?: never;
    url: '/api/v1/server/blocklist/servers/{host}';
};

export type DeleteApiV1ServerBlocklistServersByHostErrors = {
    /**
     * account block does not exist
     */
    404: unknown;
};

export type DeleteApiV1ServerBlocklistServersByHostResponses = {
    /**
     * successful operation
     */
    204: void;
};

export type DeleteApiV1ServerBlocklistServersByHostResponse = DeleteApiV1ServerBlocklistServersByHostResponses[keyof DeleteApiV1ServerBlocklistServersByHostResponses];

export type PutApiV1ServerRedundancyByHostData = {
    body?: {
        /**
         * allow mirroring of the host's local videos
         */
        redundancyAllowed: boolean;
    };
    path: {
        /**
         * server domain to mirror
         */
        host: string;
    };
    query?: never;
    url: '/api/v1/server/redundancy/{host}';
};

export type PutApiV1ServerRedundancyByHostErrors = {
    /**
     * server is not already known
     */
    404: unknown;
};

export type PutApiV1ServerRedundancyByHostResponses = {
    /**
     * successful operation
     */
    204: void;
};

export type PutApiV1ServerRedundancyByHostResponse = PutApiV1ServerRedundancyByHostResponses[keyof PutApiV1ServerRedundancyByHostResponses];

export type GetMirroredVideosData = {
    body?: never;
    path?: never;
    query: {
        /**
         * direction of the mirror
         */
        target: 'my-videos' | 'remote-videos';
        /**
         * Offset used to paginate results
         */
        start?: number;
        /**
         * Number of items to return
         */
        count?: number;
        /**
         * Sort abuses by criteria
         */
        sort?: 'name';
    };
    url: '/api/v1/server/redundancy/videos';
};

export type GetMirroredVideosResponses = {
    /**
     * successful operation
     */
    200: Array<VideoRedundancy>;
};

export type GetMirroredVideosResponse = GetMirroredVideosResponses[keyof GetMirroredVideosResponses];

export type PutMirroredVideoData = {
    body?: {
        videoId: 8;
    };
    path?: never;
    query?: never;
    url: '/api/v1/server/redundancy/videos';
};

export type PutMirroredVideoErrors = {
    /**
     * cannot mirror a local video
     */
    400: unknown;
    /**
     * video does not exist
     */
    404: unknown;
    /**
     * video is already mirrored
     */
    409: unknown;
};

export type PutMirroredVideoResponses = {
    /**
     * successful operation
     */
    204: void;
};

export type PutMirroredVideoResponse = PutMirroredVideoResponses[keyof PutMirroredVideoResponses];

export type DelMirroredVideoData = {
    body?: never;
    path: {
        /**
         * id of an existing redundancy on a video
         */
        redundancyId: string;
    };
    query?: never;
    url: '/api/v1/server/redundancy/videos/{redundancyId}';
};

export type DelMirroredVideoErrors = {
    /**
     * video redundancy not found
     */
    404: unknown;
};

export type DelMirroredVideoResponses = {
    /**
     * successful operation
     */
    204: void;
};

export type DelMirroredVideoResponse = DelMirroredVideoResponses[keyof DelMirroredVideoResponses];

export type GetInstanceStatsData = {
    body?: never;
    path?: never;
    query?: never;
    url: '/api/v1/server/stats';
};

export type GetInstanceStatsResponses = {
    /**
     * successful operation
     */
    200: ServerStats;
};

export type GetInstanceStatsResponse = GetInstanceStatsResponses[keyof GetInstanceStatsResponses];

export type SendClientLogData = {
    body?: SendClientLog;
    path?: never;
    query?: never;
    url: '/api/v1/server/logs/client';
};

export type SendClientLogResponses = {
    /**
     * successful operation
     */
    204: void;
};

export type SendClientLogResponse = SendClientLogResponses[keyof SendClientLogResponses];

export type GetInstanceLogsData = {
    body?: never;
    path?: never;
    query?: never;
    url: '/api/v1/server/logs';
};

export type GetInstanceLogsResponses = {
    /**
     * successful operation
     */
    200: Array<string>;
};

export type GetInstanceLogsResponse = GetInstanceLogsResponses[keyof GetInstanceLogsResponses];

export type GetInstanceAuditLogsData = {
    body?: never;
    path?: never;
    query?: never;
    url: '/api/v1/server/audit-logs';
};

export type GetInstanceAuditLogsResponses = {
    /**
     * successful operation
     */
    200: Array<string>;
};

export type GetInstanceAuditLogsResponse = GetInstanceAuditLogsResponses[keyof GetInstanceAuditLogsResponses];

export type GetPluginsData = {
    body?: never;
    path?: never;
    query?: {
        pluginType?: number;
        uninstalled?: boolean;
        /**
         * Offset used to paginate results
         */
        start?: number;
        /**
         * Number of items to return
         */
        count?: number;
        /**
         * Sort column
         */
        sort?: string;
    };
    url: '/api/v1/plugins';
};

export type GetPluginsResponses = {
    /**
     * successful operation
     */
    200: PluginResponse;
};

export type GetPluginsResponse = GetPluginsResponses[keyof GetPluginsResponses];

export type GetAvailablePluginsData = {
    body?: never;
    path?: never;
    query?: {
        search?: string;
        pluginType?: number;
        currentPeerTubeEngine?: string;
        /**
         * Offset used to paginate results
         */
        start?: number;
        /**
         * Number of items to return
         */
        count?: number;
        /**
         * Sort column
         */
        sort?: string;
    };
    url: '/api/v1/plugins/available';
};

export type GetAvailablePluginsErrors = {
    /**
     * plugin index unavailable
     */
    503: unknown;
};

export type GetAvailablePluginsResponses = {
    /**
     * successful operation
     */
    200: PluginResponse;
};

export type GetAvailablePluginsResponse = GetAvailablePluginsResponses[keyof GetAvailablePluginsResponses];

export type AddPluginData = {
    body?: {
        npmName: string;
    } | {
        path: string;
    };
    path?: never;
    query?: never;
    url: '/api/v1/plugins/install';
};

export type AddPluginErrors = {
    /**
     * should have either `npmName` or `path` set
     */
    400: unknown;
};

export type AddPluginResponses = {
    /**
     * successful operation
     */
    204: void;
};

export type AddPluginResponse = AddPluginResponses[keyof AddPluginResponses];

export type UpdatePluginData = {
    body?: {
        npmName: string;
    } | {
        path: string;
    };
    path?: never;
    query?: never;
    url: '/api/v1/plugins/update';
};

export type UpdatePluginErrors = {
    /**
     * should have either `npmName` or `path` set
     */
    400: unknown;
    /**
     * existing plugin not found
     */
    404: unknown;
};

export type UpdatePluginResponses = {
    /**
     * successful operation
     */
    204: void;
};

export type UpdatePluginResponse = UpdatePluginResponses[keyof UpdatePluginResponses];

export type UninstallPluginData = {
    body?: {
        /**
         * name of the plugin/theme in its package.json
         */
        npmName: string;
    };
    path?: never;
    query?: never;
    url: '/api/v1/plugins/uninstall';
};

export type UninstallPluginErrors = {
    /**
     * existing plugin not found
     */
    404: unknown;
};

export type UninstallPluginResponses = {
    /**
     * successful operation
     */
    204: void;
};

export type UninstallPluginResponse = UninstallPluginResponses[keyof UninstallPluginResponses];

export type GetPluginData = {
    body?: never;
    path: {
        /**
         * name of the plugin/theme on npmjs.com or in its package.json
         */
        npmName: string;
    };
    query?: never;
    url: '/api/v1/plugins/{npmName}';
};

export type GetPluginErrors = {
    /**
     * plugin not found
     */
    404: unknown;
};

export type GetPluginResponses = {
    /**
     * successful operation
     */
    200: Plugin;
};

export type GetPluginResponse = GetPluginResponses[keyof GetPluginResponses];

export type PutApiV1PluginsByNpmNameSettingsData = {
    body?: {
        settings?: {
            [key: string]: unknown;
        };
    };
    path: {
        /**
         * name of the plugin/theme on npmjs.com or in its package.json
         */
        npmName: string;
    };
    query?: never;
    url: '/api/v1/plugins/{npmName}/settings';
};

export type PutApiV1PluginsByNpmNameSettingsErrors = {
    /**
     * plugin not found
     */
    404: unknown;
};

export type PutApiV1PluginsByNpmNameSettingsResponses = {
    /**
     * successful operation
     */
    204: void;
};

export type PutApiV1PluginsByNpmNameSettingsResponse = PutApiV1PluginsByNpmNameSettingsResponses[keyof PutApiV1PluginsByNpmNameSettingsResponses];

export type GetApiV1PluginsByNpmNamePublicSettingsData = {
    body?: never;
    path: {
        /**
         * name of the plugin/theme on npmjs.com or in its package.json
         */
        npmName: string;
    };
    query?: never;
    url: '/api/v1/plugins/{npmName}/public-settings';
};

export type GetApiV1PluginsByNpmNamePublicSettingsErrors = {
    /**
     * plugin not found
     */
    404: unknown;
};

export type GetApiV1PluginsByNpmNamePublicSettingsResponses = {
    /**
     * successful operation
     */
    200: {
        [key: string]: unknown;
    };
};

export type GetApiV1PluginsByNpmNamePublicSettingsResponse = GetApiV1PluginsByNpmNamePublicSettingsResponses[keyof GetApiV1PluginsByNpmNamePublicSettingsResponses];

export type GetApiV1PluginsByNpmNameRegisteredSettingsData = {
    body?: never;
    path: {
        /**
         * name of the plugin/theme on npmjs.com or in its package.json
         */
        npmName: string;
    };
    query?: never;
    url: '/api/v1/plugins/{npmName}/registered-settings';
};

export type GetApiV1PluginsByNpmNameRegisteredSettingsErrors = {
    /**
     * plugin not found
     */
    404: unknown;
};

export type GetApiV1PluginsByNpmNameRegisteredSettingsResponses = {
    /**
     * successful operation
     */
    200: {
        [key: string]: unknown;
    };
};

export type GetApiV1PluginsByNpmNameRegisteredSettingsResponse = GetApiV1PluginsByNpmNameRegisteredSettingsResponses[keyof GetApiV1PluginsByNpmNameRegisteredSettingsResponses];

export type PostApiV1MetricsPlaybackData = {
    body?: PlaybackMetricCreate;
    path?: never;
    query?: never;
    url: '/api/v1/metrics/playback';
};

export type PostApiV1MetricsPlaybackResponses = {
    /**
     * successful operation
     */
    204: void;
};

export type PostApiV1MetricsPlaybackResponse = PostApiV1MetricsPlaybackResponses[keyof PostApiV1MetricsPlaybackResponses];

export type PostApiV1RunnersRegistrationTokensGenerateData = {
    body?: never;
    path?: never;
    query?: never;
    url: '/api/v1/runners/registration-tokens/generate';
};

export type PostApiV1RunnersRegistrationTokensGenerateResponses = {
    /**
     * successful operation
     */
    204: void;
};

export type PostApiV1RunnersRegistrationTokensGenerateResponse = PostApiV1RunnersRegistrationTokensGenerateResponses[keyof PostApiV1RunnersRegistrationTokensGenerateResponses];

export type DeleteApiV1RunnersRegistrationTokensByRegistrationTokenIdData = {
    body?: never;
    path: {
        registrationTokenId: number;
    };
    query?: never;
    url: '/api/v1/runners/registration-tokens/{registrationTokenId}';
};

export type DeleteApiV1RunnersRegistrationTokensByRegistrationTokenIdResponses = {
    /**
     * successful operation
     */
    204: void;
};

export type DeleteApiV1RunnersRegistrationTokensByRegistrationTokenIdResponse = DeleteApiV1RunnersRegistrationTokensByRegistrationTokenIdResponses[keyof DeleteApiV1RunnersRegistrationTokensByRegistrationTokenIdResponses];

export type GetApiV1RunnersRegistrationTokensData = {
    body?: never;
    path?: never;
    query?: {
        /**
         * Offset used to paginate results
         */
        start?: number;
        /**
         * Number of items to return
         */
        count?: number;
        /**
         * Sort registration tokens by criteria
         */
        sort?: 'createdAt';
    };
    url: '/api/v1/runners/registration-tokens';
};

export type GetApiV1RunnersRegistrationTokensResponses = {
    /**
     * successful operation
     */
    200: {
        total?: number;
        data?: Array<RunnerRegistrationToken>;
    };
};

export type GetApiV1RunnersRegistrationTokensResponse = GetApiV1RunnersRegistrationTokensResponses[keyof GetApiV1RunnersRegistrationTokensResponses];

export type PostApiV1RunnersRegisterData = {
    body?: {
        registrationToken: string;
        name: string;
        description?: string;
    };
    path?: never;
    query?: never;
    url: '/api/v1/runners/register';
};

export type PostApiV1RunnersRegisterResponses = {
    /**
     * successful operation
     */
    200: {
        /**
         * Runner id
         */
        id?: number;
        runnerToken?: string;
    };
};

export type PostApiV1RunnersRegisterResponse = PostApiV1RunnersRegisterResponses[keyof PostApiV1RunnersRegisterResponses];

export type PostApiV1RunnersUnregisterData = {
    body?: {
        runnerToken: string;
    };
    path?: never;
    query?: never;
    url: '/api/v1/runners/unregister';
};

export type PostApiV1RunnersUnregisterResponses = {
    /**
     * successful operation
     */
    204: void;
};

export type PostApiV1RunnersUnregisterResponse = PostApiV1RunnersUnregisterResponses[keyof PostApiV1RunnersUnregisterResponses];

export type DeleteApiV1RunnersByRunnerIdData = {
    body?: {
        runnerToken: string;
    };
    path: {
        runnerId: number;
    };
    query?: never;
    url: '/api/v1/runners/{runnerId}';
};

export type DeleteApiV1RunnersByRunnerIdResponses = {
    /**
     * successful operation
     */
    204: void;
};

export type DeleteApiV1RunnersByRunnerIdResponse = DeleteApiV1RunnersByRunnerIdResponses[keyof DeleteApiV1RunnersByRunnerIdResponses];

export type GetApiV1RunnersData = {
    body?: never;
    path?: never;
    query?: {
        /**
         * Offset used to paginate results
         */
        start?: number;
        /**
         * Number of items to return
         */
        count?: number;
        /**
         * Sort runners by criteria
         */
        sort?: 'createdAt';
    };
    url: '/api/v1/runners';
};

export type GetApiV1RunnersResponses = {
    /**
     * successful operation
     */
    200: {
        total?: number;
        data?: Array<Runner>;
    };
};

export type GetApiV1RunnersResponse = GetApiV1RunnersResponses[keyof GetApiV1RunnersResponses];

export type PostApiV1RunnersJobsRequestData = {
    body?: {
        runnerToken: string;
        /**
         * Filter jobs depending on their types
         */
        jobTypes?: Array<string>;
    };
    path?: never;
    query?: never;
    url: '/api/v1/runners/jobs/request';
};

export type PostApiV1RunnersJobsRequestResponses = {
    /**
     * successful operation
     */
    200: {
        availableJobs?: Array<{
            uuid?: UuiDv4;
            type?: RunnerJobType;
            payload?: RunnerJobPayload;
        }>;
    };
};

export type PostApiV1RunnersJobsRequestResponse = PostApiV1RunnersJobsRequestResponses[keyof PostApiV1RunnersJobsRequestResponses];

export type PostApiV1RunnersJobsByJobUuidAcceptData = {
    body?: {
        runnerToken: string;
    };
    path: {
        jobUUID: UuiDv4;
    };
    query?: never;
    url: '/api/v1/runners/jobs/{jobUUID}/accept';
};

export type PostApiV1RunnersJobsByJobUuidAcceptResponses = {
    /**
     * successful operation
     */
    200: {
        job?: RunnerJob & {
            jobToken?: string;
        };
    };
};

export type PostApiV1RunnersJobsByJobUuidAcceptResponse = PostApiV1RunnersJobsByJobUuidAcceptResponses[keyof PostApiV1RunnersJobsByJobUuidAcceptResponses];

export type PostApiV1RunnersJobsByJobUuidAbortData = {
    body?: {
        runnerToken: string;
        jobToken: string;
        /**
         * Why the runner aborts this job
         */
        reason: string;
    };
    path: {
        jobUUID: UuiDv4;
    };
    query?: never;
    url: '/api/v1/runners/jobs/{jobUUID}/abort';
};

export type PostApiV1RunnersJobsByJobUuidAbortResponses = {
    /**
     * successful operation
     */
    204: void;
};

export type PostApiV1RunnersJobsByJobUuidAbortResponse = PostApiV1RunnersJobsByJobUuidAbortResponses[keyof PostApiV1RunnersJobsByJobUuidAbortResponses];

export type PostApiV1RunnersJobsByJobUuidUpdateData = {
    body?: {
        runnerToken: string;
        jobToken: string;
        /**
         * Update job progression percentage (optional)
         */
        progress?: number;
        /**
         * Provide live transcoding chunks update
         */
        payload?: {
            type?: 'add-chunk' | 'remove-chunk';
            masterPlaylistFile?: Blob | File;
            resolutionPlaylistFile?: Blob | File;
            resolutionPlaylistFilename?: string;
            videoChunkFile?: Blob | File;
            videoChunkFilename?: string;
        };
    };
    path: {
        jobUUID: UuiDv4;
    };
    query?: never;
    url: '/api/v1/runners/jobs/{jobUUID}/update';
};

export type PostApiV1RunnersJobsByJobUuidUpdateResponses = {
    /**
     * successful operation
     */
    204: void;
};

export type PostApiV1RunnersJobsByJobUuidUpdateResponse = PostApiV1RunnersJobsByJobUuidUpdateResponses[keyof PostApiV1RunnersJobsByJobUuidUpdateResponses];

export type PostApiV1RunnersJobsByJobUuidErrorData = {
    body?: {
        runnerToken: string;
        jobToken: string;
        /**
         * Why the runner failed to process this job
         */
        message: string;
    };
    path: {
        jobUUID: UuiDv4;
    };
    query?: never;
    url: '/api/v1/runners/jobs/{jobUUID}/error';
};

export type PostApiV1RunnersJobsByJobUuidErrorResponses = {
    /**
     * successful operation
     */
    204: void;
};

export type PostApiV1RunnersJobsByJobUuidErrorResponse = PostApiV1RunnersJobsByJobUuidErrorResponses[keyof PostApiV1RunnersJobsByJobUuidErrorResponses];

export type PostApiV1RunnersJobsByJobUuidSuccessData = {
    body?: {
        runnerToken: string;
        jobToken: string;
        payload: {
            videoFile?: Blob | File;
        } | {
            videoFile?: Blob | File;
            resolutionPlaylistFile?: Blob | File;
        } | {
            videoFile?: Blob | File;
        } | {
            [key: string]: unknown;
        };
    };
    path: {
        jobUUID: UuiDv4;
    };
    query?: never;
    url: '/api/v1/runners/jobs/{jobUUID}/success';
};

export type PostApiV1RunnersJobsByJobUuidSuccessResponses = {
    /**
     * successful operation
     */
    204: void;
};

export type PostApiV1RunnersJobsByJobUuidSuccessResponse = PostApiV1RunnersJobsByJobUuidSuccessResponses[keyof PostApiV1RunnersJobsByJobUuidSuccessResponses];

export type GetApiV1RunnersJobsByJobUuidCancelData = {
    body?: never;
    path: {
        jobUUID: UuiDv4;
    };
    query?: never;
    url: '/api/v1/runners/jobs/{jobUUID}/cancel';
};

export type GetApiV1RunnersJobsByJobUuidCancelResponses = {
    /**
     * successful operation
     */
    204: void;
};

export type GetApiV1RunnersJobsByJobUuidCancelResponse = GetApiV1RunnersJobsByJobUuidCancelResponses[keyof GetApiV1RunnersJobsByJobUuidCancelResponses];

export type DeleteApiV1RunnersJobsByJobUuidData = {
    body?: never;
    path: {
        jobUUID: UuiDv4;
    };
    query?: never;
    url: '/api/v1/runners/jobs/{jobUUID}';
};

export type DeleteApiV1RunnersJobsByJobUuidResponses = {
    /**
     * successful operation
     */
    204: void;
};

export type DeleteApiV1RunnersJobsByJobUuidResponse = DeleteApiV1RunnersJobsByJobUuidResponses[keyof DeleteApiV1RunnersJobsByJobUuidResponses];

export type GetApiV1RunnersJobsData = {
    body?: never;
    path?: never;
    query?: {
        /**
         * Offset used to paginate results
         */
        start?: number;
        /**
         * Number of items to return
         */
        count?: number;
        /**
         * Sort runner jobs by criteria
         */
        sort?: 'updatedAt' | 'createdAt' | 'priority' | 'state' | 'progress';
        /**
         * Plain text search, applied to various parts of the model depending on endpoint
         */
        search?: string;
        stateOneOf?: Array<RunnerJobState>;
    };
    url: '/api/v1/runners/jobs';
};

export type GetApiV1RunnersJobsResponses = {
    /**
     * successful operation
     */
    200: {
        total?: number;
        data?: Array<RunnerJobAdmin>;
    };
};

export type GetApiV1RunnersJobsResponse = GetApiV1RunnersJobsResponses[keyof GetApiV1RunnersJobsResponses];

export type GetApiV1AutomaticTagsPoliciesAccountsByAccountNameCommentsData = {
    body?: never;
    path: {
        /**
         * account name to get auto tag policies
         */
        accountName: string;
    };
    query?: never;
    url: '/api/v1/automatic-tags/policies/accounts/{accountName}/comments';
};

export type GetApiV1AutomaticTagsPoliciesAccountsByAccountNameCommentsResponses = {
    /**
     * successful operation
     */
    200: CommentAutoTagPolicies;
};

export type GetApiV1AutomaticTagsPoliciesAccountsByAccountNameCommentsResponse = GetApiV1AutomaticTagsPoliciesAccountsByAccountNameCommentsResponses[keyof GetApiV1AutomaticTagsPoliciesAccountsByAccountNameCommentsResponses];

export type PutApiV1AutomaticTagsPoliciesAccountsByAccountNameCommentsData = {
    body?: {
        /**
         * Auto tags that automatically set the comment in review state
         */
        review?: Array<string>;
    };
    path: {
        /**
         * account name to update auto tag policies
         */
        accountName: string;
    };
    query?: never;
    url: '/api/v1/automatic-tags/policies/accounts/{accountName}/comments';
};

export type PutApiV1AutomaticTagsPoliciesAccountsByAccountNameCommentsResponses = {
    /**
     * successful operation
     */
    204: void;
};

export type PutApiV1AutomaticTagsPoliciesAccountsByAccountNameCommentsResponse = PutApiV1AutomaticTagsPoliciesAccountsByAccountNameCommentsResponses[keyof PutApiV1AutomaticTagsPoliciesAccountsByAccountNameCommentsResponses];

export type GetApiV1AutomaticTagsAccountsByAccountNameAvailableData = {
    body?: never;
    path: {
        /**
         * account name to get auto tag policies
         */
        accountName: string;
    };
    query?: never;
    url: '/api/v1/automatic-tags/accounts/{accountName}/available';
};

export type GetApiV1AutomaticTagsAccountsByAccountNameAvailableResponses = {
    /**
     * successful operation
     */
    200: AutomaticTagAvailable;
};

export type GetApiV1AutomaticTagsAccountsByAccountNameAvailableResponse = GetApiV1AutomaticTagsAccountsByAccountNameAvailableResponses[keyof GetApiV1AutomaticTagsAccountsByAccountNameAvailableResponses];

export type GetApiV1AutomaticTagsServerAvailableData = {
    body?: never;
    path?: never;
    query?: never;
    url: '/api/v1/automatic-tags/server/available';
};

export type GetApiV1AutomaticTagsServerAvailableResponses = {
    /**
     * successful operation
     */
    200: AutomaticTagAvailable;
};

export type GetApiV1AutomaticTagsServerAvailableResponse = GetApiV1AutomaticTagsServerAvailableResponses[keyof GetApiV1AutomaticTagsServerAvailableResponses];

export type GetApiV1WatchedWordsAccountsByAccountNameListsData = {
    body?: never;
    path: {
        /**
         * account name to list watched words
         */
        accountName: string;
    };
    query?: never;
    url: '/api/v1/watched-words/accounts/{accountName}/lists';
};

export type GetApiV1WatchedWordsAccountsByAccountNameListsResponses = {
    /**
     * successful operation
     */
    200: {
        total?: number;
        data?: Array<WatchedWordsLists>;
    };
};

export type GetApiV1WatchedWordsAccountsByAccountNameListsResponse = GetApiV1WatchedWordsAccountsByAccountNameListsResponses[keyof GetApiV1WatchedWordsAccountsByAccountNameListsResponses];

export type PostApiV1WatchedWordsAccountsByAccountNameListsData = {
    body?: {
        listName?: string;
        words?: Array<string>;
    };
    path: {
        accountName: string;
    };
    query?: never;
    url: '/api/v1/watched-words/accounts/{accountName}/lists';
};

export type PostApiV1WatchedWordsAccountsByAccountNameListsResponses = {
    /**
     * successful operation
     */
    200: {
        watchedWordsList?: {
            id?: number;
        };
    };
};

export type PostApiV1WatchedWordsAccountsByAccountNameListsResponse = PostApiV1WatchedWordsAccountsByAccountNameListsResponses[keyof PostApiV1WatchedWordsAccountsByAccountNameListsResponses];

export type DeleteApiV1WatchedWordsAccountsByAccountNameListsByListIdData = {
    body?: never;
    path: {
        accountName: string;
        /**
         * list of watched words to delete
         */
        listId: string;
    };
    query?: never;
    url: '/api/v1/watched-words/accounts/{accountName}/lists/{listId}';
};

export type DeleteApiV1WatchedWordsAccountsByAccountNameListsByListIdResponses = {
    /**
     * successful operation
     */
    204: void;
};

export type DeleteApiV1WatchedWordsAccountsByAccountNameListsByListIdResponse = DeleteApiV1WatchedWordsAccountsByAccountNameListsByListIdResponses[keyof DeleteApiV1WatchedWordsAccountsByAccountNameListsByListIdResponses];

export type PutApiV1WatchedWordsAccountsByAccountNameListsByListIdData = {
    body?: {
        listName?: string;
        words?: Array<string>;
    };
    path: {
        accountName: string;
        /**
         * list of watched words to update
         */
        listId: string;
    };
    query?: never;
    url: '/api/v1/watched-words/accounts/{accountName}/lists/{listId}';
};

export type PutApiV1WatchedWordsAccountsByAccountNameListsByListIdResponses = {
    /**
     * successful operation
     */
    204: void;
};

export type PutApiV1WatchedWordsAccountsByAccountNameListsByListIdResponse = PutApiV1WatchedWordsAccountsByAccountNameListsByListIdResponses[keyof PutApiV1WatchedWordsAccountsByAccountNameListsByListIdResponses];

export type GetApiV1WatchedWordsServerListsData = {
    body?: never;
    path?: never;
    query?: never;
    url: '/api/v1/watched-words/server/lists';
};

export type GetApiV1WatchedWordsServerListsResponses = {
    /**
     * successful operation
     */
    200: {
        total?: number;
        data?: Array<WatchedWordsLists>;
    };
};

export type GetApiV1WatchedWordsServerListsResponse = GetApiV1WatchedWordsServerListsResponses[keyof GetApiV1WatchedWordsServerListsResponses];

export type PostApiV1WatchedWordsServerListsData = {
    body?: {
        listName?: string;
        words?: Array<string>;
    };
    path?: never;
    query?: never;
    url: '/api/v1/watched-words/server/lists';
};

export type PostApiV1WatchedWordsServerListsResponses = {
    /**
     * successful operation
     */
    200: {
        watchedWordsList?: {
            id?: number;
        };
    };
};

export type PostApiV1WatchedWordsServerListsResponse = PostApiV1WatchedWordsServerListsResponses[keyof PostApiV1WatchedWordsServerListsResponses];

export type DeleteApiV1WatchedWordsServerListsByListIdData = {
    body?: never;
    path: {
        /**
         * list of watched words to delete
         */
        listId: string;
    };
    query?: never;
    url: '/api/v1/watched-words/server/lists/{listId}';
};

export type DeleteApiV1WatchedWordsServerListsByListIdResponses = {
    /**
     * successful operation
     */
    204: void;
};

export type DeleteApiV1WatchedWordsServerListsByListIdResponse = DeleteApiV1WatchedWordsServerListsByListIdResponses[keyof DeleteApiV1WatchedWordsServerListsByListIdResponses];

export type PutApiV1WatchedWordsServerListsByListIdData = {
    body?: {
        listName?: string;
        words?: Array<string>;
    };
    path: {
        /**
         * list of watched words to update
         */
        listId: string;
    };
    query?: never;
    url: '/api/v1/watched-words/server/lists/{listId}';
};

export type PutApiV1WatchedWordsServerListsByListIdResponses = {
    /**
     * successful operation
     */
    204: void;
};

export type PutApiV1WatchedWordsServerListsByListIdResponse = PutApiV1WatchedWordsServerListsByListIdResponses[keyof PutApiV1WatchedWordsServerListsByListIdResponses];

export type UpdateClientLanguageData = {
    body?: {
        /**
         * Language code to set
         */
        language: string;
    };
    path?: never;
    query?: never;
    url: '/api/v1/client-config/update-language';
};

export type UpdateClientLanguageResponses = {
    /**
     * successful operation
     */
    204: void;
};

export type UpdateClientLanguageResponse = UpdateClientLanguageResponses[keyof UpdateClientLanguageResponses];

export type ClientOptions = {
    baseUrl: 'https://peertube2.cpy.re' | 'https://peertube3.cpy.re' | 'https://peertube.cpy.re' | (string & {});
};
