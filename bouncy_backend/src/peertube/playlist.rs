use crate::{
    peertube::{
        channel::PeerTubeChannelId, check_peertube_system_user_response, user::PeerTubeAccount,
        PeerTubeError,
    },
    AppState,
};
use uuid::Uuid;

#[derive(Debug, Clone, serde::Deserialize)]
pub(crate) struct PeerTubePlaylist {
    pub id: PeerTubePlaylistId,
    #[allow(dead_code)]
    pub uuid: Uuid,
    #[serde(alias = "shortUUID")]
    pub short_uuid: String,
}

/// This is the same on PeerTube and in the BF API DB, generated by PeerTube.
#[derive(Clone, Copy, Debug, serde::Deserialize, serde::Serialize)]
#[serde(transparent)]
pub(crate) struct PeerTubePlaylistId(pub i64);

#[derive(Clone, Copy, Debug, serde::Deserialize, serde::Serialize)]
#[serde(transparent)]
pub(crate) struct PeerTubeVideoId(pub i64);

#[derive(Debug, Clone, serde::Deserialize)]
pub(crate) struct PlaylistCreatedResponse {
    #[serde(alias = "videoPlaylist")]
    video_playlist: PeerTubePlaylist,
}

#[derive(Clone, Copy, Debug)]
pub(crate) enum PlaylistPrivacy {
    Public = 1,
    Unlisted = 2,
    #[allow(dead_code)]
    Private = 3,
}

#[derive(Debug, Clone, serde::Deserialize)]
pub(crate) struct VideoAddedResponse {
    #[serde(alias = "videoPlaylistElement")]
    video_playlist_element: PlaylistElement,
}

#[derive(Debug, Clone, serde::Deserialize)]
pub(crate) struct PlaylistElement {
    pub id: u64,
}

#[derive(Debug, Clone, serde::Deserialize)]
struct ListPlaylistVideosResponse {
    data: Vec<PlaylistVideoElement>,
}

#[derive(Debug, Clone, serde::Deserialize)]
pub(crate) struct PlaylistVideoElement {
    /// playlist element id
    pub id: u64,
    #[allow(dead_code)]
    pub position: u64,
    #[allow(dead_code)]
    pub video: PlaylistVideo,
}

#[derive(Debug, Clone, serde::Deserialize)]
pub(crate) struct PlaylistVideo {
    pub id: PeerTubeVideoId,
    pub account: PeerTubeAccount,
    // other fields omitted
}

pub(crate) async fn list_system_playlist(
    state: &AppState,
    // must be uuid or short uuid to work with unlisted playlists
    playlist_id: &str,
    start: u64,
    count: u64,
) -> Result<Vec<PlaylistVideoElement>, PeerTubeError> {
    let url = state
        .peertube_url
        .join(&format!("api/v1/video-playlists/{playlist_id}/videos"))
        .expect("must be valid url");

    let token = state.system_user.access_token(state).await?;

    let response = state
        .http_client
        .get(url.as_str())
        .query(&[("start", start), ("count", count)])
        .bearer_auth(&token)
        .send()
        .await;

    let ok_response = check_peertube_system_user_response(response, token).await?;
    let status = ok_response.status();
    let msg: Result<ListPlaylistVideosResponse, _> = ok_response.json().await;
    let msg = msg.map_err(|err| PeerTubeError::JsonParsingFailed(status, err))?;
    Ok(msg.data)
}

/// Creates an impersonal (system) playlist on PeerTube that's unlisted.
pub(crate) async fn create_unlisted_system_playlist(
    state: &AppState,
    display_name: &str,
    description: &str,
    channel_id: PeerTubeChannelId,
) -> Result<PeerTubePlaylist, PeerTubeError> {
    if description.is_empty() {
        let body = [
            ("displayName", display_name),
            ("privacy", PlaylistPrivacy::Unlisted.to_num_str()),
            ("videoChannelId", &channel_id.num().to_string()),
        ];
        create_system_playlist(state, &body).await
    } else {
        let body = [
            ("displayName", display_name),
            ("description", description),
            ("privacy", PlaylistPrivacy::Unlisted.to_num_str()),
            ("videoChannelId", &channel_id.num().to_string()),
        ];
        create_system_playlist(state, &body).await
    }
}

/// Creates an impersonal (system) playlist on PeerTube that's publicly listed.
pub(crate) async fn create_public_system_playlist(
    state: &AppState,
    display_name: &str,
    description: &str,
    channel_id: PeerTubeChannelId,
) -> Result<PeerTubePlaylist, PeerTubeError> {
    if description.is_empty() {
        let body = [
            ("displayName", display_name),
            ("privacy", PlaylistPrivacy::Public.to_num_str()),
            ("videoChannelId", &channel_id.num().to_string()),
        ];
        create_system_playlist(state, &body).await
    } else {
        let body = [
            ("displayName", display_name),
            ("description", description),
            ("privacy", PlaylistPrivacy::Public.to_num_str()),
            ("videoChannelId", &channel_id.num().to_string()),
        ];
        create_system_playlist(state, &body).await
    }
}

async fn create_system_playlist<T: serde::Serialize + ?Sized>(
    state: &AppState,
    body: &T,
) -> Result<PeerTubePlaylist, PeerTubeError> {
    let url = state
        .peertube_url
        .join("api/v1/video-playlists")
        .expect("must be valid url");

    let token = state.system_user.access_token(state).await?;

    let response = state
        .http_client
        .post(url.as_str())
        .form(body)
        .bearer_auth(&token)
        .send()
        .await;

    let ok_response = check_peertube_system_user_response(response, token).await?;
    let status = ok_response.status();
    let playlist: Result<PlaylistCreatedResponse, _> = ok_response.json().await;
    let playlist = playlist.map_err(|err| PeerTubeError::JsonParsingFailed(status, err))?;
    Ok(playlist.video_playlist)
}

pub(crate) async fn add_video_to_playlist(
    state: &AppState,
    video_id: i64,
    playlist_id: PeerTubePlaylistId,
) -> Result<PlaylistElement, PeerTubeError> {
    let url = state
        .peertube_url
        .join(&format!(
            "api/v1/video-playlists/{}/videos",
            playlist_id.num()
        ))
        .expect("must be valid url");

    let token = state.system_user.access_token(state).await?;

    let response = state
        .http_client
        .post(url.as_str())
        .form(&[("videoId", video_id)])
        .bearer_auth(&token)
        .send()
        .await;

    let ok_response = check_peertube_system_user_response(response, token).await?;
    let status = ok_response.status();
    let msg: Result<VideoAddedResponse, _> = ok_response.json().await;
    let msg = msg.map_err(|err| PeerTubeError::JsonParsingFailed(status, err))?;
    Ok(msg.video_playlist_element)
}

pub(crate) async fn remove_video_from_playlist(
    state: &AppState,
    playlist_id: PeerTubePlaylistId,
    element_index: u64,
) -> Result<(), PeerTubeError> {
    let url = state
        .peertube_url
        .join(&format!(
            "api/v1/video-playlists/{}/videos/{element_index}",
            playlist_id.num(),
        ))
        .expect("must be valid url");

    let token = state.system_user.access_token(state).await?;

    let response = state
        .http_client
        .delete(url.as_str())
        .bearer_auth(&token)
        .send()
        .await;

    check_peertube_system_user_response(response, token).await?;
    Ok(())
}

impl PlaylistPrivacy {
    #[inline(always)]
    fn to_num_str(self) -> &'static str {
        match self as usize {
            1 => "1",
            2 => "2",
            3 => "3",
            _ => unreachable!("should not have other variants"),
        }
    }
}

pub async fn update_system_playlist(
    state: &AppState,
    playlist_id: PeerTubePlaylistId,
    display_name: &str,
    description: &str,
    channel_id: PeerTubeChannelId,
    privacy: PlaylistPrivacy,
) -> Result<(), PeerTubeError> {
    let channel_id = channel_id.num().to_string();
    let body = if description.is_empty() {
        vec![
            ("displayName", display_name),
            ("privacy", privacy.to_num_str()),
            ("videoChannelId", &channel_id),
        ]
    } else {
        vec![
            ("displayName", display_name),
            ("description", description),
            ("privacy", privacy.to_num_str()),
            ("videoChannelId", &channel_id),
        ]
    };

    let relative_path = format!("api/v1/video-playlists/{}", playlist_id.num());
    let url = state
        .peertube_url
        .join(&relative_path)
        .expect("must be valid url");

    let token = state.system_user.access_token(state).await?;

    let response = state
        .http_client
        .put(url.as_str())
        .form(&body)
        .bearer_auth(&token)
        .send()
        .await;

    check_peertube_system_user_response(response, token).await?;
    Ok(())
}

impl PeerTubePlaylistId {
    pub fn num(&self) -> i64 {
        self.0
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_playlist_privacy_enum_to_num_str() {
        check_enum_to_num_str(PlaylistPrivacy::Private);
        check_enum_to_num_str(PlaylistPrivacy::Public);
        check_enum_to_num_str(PlaylistPrivacy::Unlisted);
    }

    #[track_caller]
    fn check_enum_to_num_str(variant: PlaylistPrivacy) {
        assert_eq!((variant as usize).to_string(), variant.to_num_str());
    }
}
